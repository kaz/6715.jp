---
title: メルセンヌ・ツイスタをわかった気になる
date: 2016-06-26 03:45:00
id: 5
tags: [メルセンヌ・ツイスタ, 乱数]
category: 技術
---

メルセンヌ・ツイスタについて。

<!-- more -->

メルセンヌ・ツイスタ(MT)は擬似乱数列を作るアルゴリズムの一つで、他の手法と比べると欠点が少なくて高品質な擬似乱数列を高速に作れるんだって。スゴイ！
プログラムをかじった人なら、多分聞いたことがあるんじゃないかと思います。

日本初のアルゴリズムだし、日本語文献あるかな？って思ったんですけど、良い物が見つからなかった（かなしい）ので、
元の[論文](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf)を読みながら**Perl**でMTを実装して理解を深めたいと思います。

なんか強いアルゴリズムだ！って聞くとめっちゃ複雑なんじゃないかって思いがちですけど、MTはとっても<span style="font-size:1.5em">**†単純†**</span>です。

# MTの定義

{% math %} w {% endmath %} ビットの整数からなる乱数列を生成する場合を考えます。
この時、整数を {% math %} w {% endmath %} 次元行ベクトルとして考えることとします。

すると、MTによって生成される乱数列は以下の漸化式によって表されます。

{% math %}
\mathbf{x}_{k+n} = \mathbf{x}_{k+m} \oplus ( \mathbf{x}^u_k \: | \: \mathbf{x}^l_{k+1} ) A
\:\:\:\: (k = 0,1, \cdots)
{% endmath %}

この式に登場する {% math %} n,m {% endmath %} は定数で、{% math %} 1 \le m \le n {% endmath %} を満たします。

{% math %} ( \mathbf{x}^u_k \: | \: \mathbf{x}^l_{k+1} ) {% endmath %} は、{% math %} \mathbf{x}_k {% endmath %} の上位 {% math %} w-r {% endmath %}ビットと {% math %} \mathbf{x}_{k+1} {% endmath %} の下位 {% math %} r {% endmath %}ビットを連結した行ベクトルを表しています。
この {% math %} r {% endmath %} も定数で、{% math %} 0 \le r \le w-1 {% endmath %} を満たします。

{% math %} A {% endmath %} は以下のように定義された {% math %} w \times w {% endmath %} 正方行列です。

{% math %}
A = \left(
	\begin{array}{ccccc}
		0 & 1 & 0 & 0 & 0 \\
		0 & 0 & 1 & 0 & 0 \\
		0 & 0 & 0 & \ddots & 0 \\
		0 & 0 & 0 & 0 & 1 \\
		a_{w-1} & a_{w-2} & \cdots & \cdots & a_0
	\end{array}
\right)
{% endmath %}

これによって、{% math %} \mathbf{x} A {% endmath %} を以下のように高速に計算することができます。

{% math %}
\begin{array}{c}
	\mathbf{x} A = \begin{cases}
		(\mathbf{x} \gg 1) & (x_0 = 0) \\
		(\mathbf{x} \gg 1) \oplus \mathbf{a} & (x_0 = 1)
	\end{cases} \\
	\\
	\mathbf{x} = (x_{w-1}, x_{w-2}, \cdots, x_0) \\
	\mathbf{a} = (a_{w-1}, a_{w-2}, \cdots, a_0)
\end{array}
{% endmath %}

こうして、{% math %} w {% endmath %} ビットの整数、もとい {% math %} w {% endmath %} 次元行ベクトルがたくさんできるわけですが、
これをそのまま乱数として出力するのはなんだかマズいらしくて、
値を程よく分布させるため、出力する行ベクトルに {% math %} w \times w {% endmath %} の適当な**正則行列** {% math %} T {% endmath %} を右から掛けます。

{% math %} T {% endmath %} を右から掛ける事に相当する演算として、実際には以下の様な演算を行います。

{% math %}
\begin{array}{l}
	\mathbf{y}_1 = \mathbf{x} \oplus (\mathbf{x} \gg u) \\
	\mathbf{y}_2 = \mathbf{y_1} \oplus ((\mathbf{y}_1 \ll s) \: \& \: \mathbf{b}) \\
	\mathbf{y}_3 = \mathbf{y_2} \oplus ((\mathbf{y}_2 \ll t) \: \& \: \mathbf{c}) \\
	\mathbf{y}_4 = \mathbf{y_3} \oplus (\mathbf{y}_3 \gg l)
\end{array}
{% endmath %}

{% math %} u,s,t,l {% endmath %} は定数で、&はビットAND演算を表し、{% math %} \mathbf{b}, \mathbf{c} {% endmath %} は適当な行ベクトルです。

こうして得られた {% math %} \mathbf{y_4} {% endmath %} を出力します。
（この操作を _Tempering_ と言うそうです。）

で、途中にいろいろ定数やらなんやらが登場したんですが、これらを

{% math %}
\begin{array}{l}
	w = 32 \\
	n = 624 \\
	m = 397 \\
	r = 31 \\
	u = 11 \\
	s = 7 \\
	t = 15 \\
	l = 18 \\
	\mathbf{a} = \mathbf{0x9908B0DF} \\
	\mathbf{b} = \mathbf{0x9D2C5680} \\
	\mathbf{c} = \mathbf{0xEFC60000}
\end{array}
{% endmath %}

とすると、周期が {% math %} 2^{19937}-1 {% endmath %} とめちゃくちゃ長い、かの有名なMT19937になります。

# MTを実装する

なんだか、 _は？_ ってカンジですね。

整理すると、

- 長さnの配列を用意して、適当な値で埋める（これがシード値になります）
- i番目の乱数を得る
 - Step.1 `z = (x[i] & 0b111..1000..0 | x[(i+1)%n] & 0b000..0111..1)` を計算する
 - Step.2 `x[i] = x[(i+m)%n] ^ (z >> 1) ^ ((z & 1) == 0 ? 0 : a)` を計算する
 - Step.3 Temperingした値を返す
 
これだけです。シンプルだ！
 
Step.1は {% math %} ( \mathbf{x}^u_k \: | \: \mathbf{x}^l_{k+1} ) {% endmath %} を求めることに相当します。
Step.2は 最初の漸化式を適用することに相当し、XORで繋がれた後ろの2項は、行列 {% math %} A {% endmath %} を掛けることに相当します。
 
自分みたいなプログラマな人間は、たぶんソースコードを見れば一発で理解できると思います。
（Perlで書くんですけどネ。）

ということで、書いてみたのが以下。

```perl
use strict;

# MT19937
my $w = 32;
my $n = 624;
my $m = 397;
my $r = 31;
my $u = 11;
my $s = 7;
my $t = 15;
my $l = 18;
my $a = 0x9908B0DF;
my $b = 0x9D2C5680;
my $c = 0xEFC60000;

# MT乱数列
my $i = 0;
my @x = ();

# ビットマスクの準備
my $mask_u = 0;
my $mask_l = 0;
for(my $j = 0; $j < $w; $j++){
	$mask_u = ($mask_u << 1) + ($j < $w - $r);
	$mask_l = ($mask_l << 1) + ($j >= $w - $r);
}

# seedを受け取ってxを初期化 (mt19937ar.cに準拠)
sub init_genrand {
	my($seed) = @_;
	$x[0] = $seed & 0xFFFFFFFF;
	for(my $j = 1; $j < $n; $j++){
		$x[$j] = (1812433253 * ($x[$j-1] ^ ($x[$j-1] >> 30)) + $j) & 0xFFFFFFFF; 
	}
}

# 乱数を生成
sub genrand_int {
	# Step.1
	my $z = ($x[$i] & $mask_u | $x[($i+1) % $n] & $mask_l);
	
	# Step.2
	$x[$i] = $x[($i+$m) % $n] ^ ($z >> 1) ^ (($z & 1) == 0 ? 0 : $a);
	
	# Step.3
	my $y = $x[$i];
	$y = $y ^ ($y >> $u);
	$y = $y ^ (($y << $s) & $b);
	$y = $y ^ (($y << $t) & $c);
	$y = $y ^ ($y >> $l);
	
	# カウンタを変更して、生成した乱数を返す
	$i = ($i+1) % $n;
	return $y;
}

# 使ってみる
init_genrand(20150919);
for(my $j = 1; $j <= 128; $j++){
	print $j, ": ", genrand_int(), "\n";
}
```

（あんまり自信がないですが、MTの考案者が書いた[C++プログラム](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c)と出力が一致したので、多分大丈夫。）

こうやってみると、本当に**単純**ですね！
それでいて性能がたいへんよろしいのですから、スゴイものです。

# 発展

とりあえずMTがこういうものだって、わかった気になれたわけです。
個人的には、 _Tempering_ のトコロが面白いと思っていて、ココをもうちょっと掘り下げてみたいと思います。

Temperingは正則行列 {% math %} T {% endmath %} を右から掛ける演算ですが、
この {% math %} T {% endmath %} が実際にはどんな行列なのかには、触れませんでした。

でも、正則行列ってことは**逆行列**が存在して、Temperingの逆演算もできて……？
みたいなお話です。（なんか楽しそうな気がしません？）

ということで、次回に続く！！！