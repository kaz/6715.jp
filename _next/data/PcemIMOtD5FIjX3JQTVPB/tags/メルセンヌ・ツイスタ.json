{"pageProps":{"tag":"メルセンヌ・ツイスタ","entries":[{"type":"article","slug":"6","body":"メルセンヌ・ツイスタの性質を理解したい。\n\nこの記事は前回の続きです。\n\n[メルセンヌ・ツイスタをわかった気になる](/posts/5/)\n\n## 今日のテーマ\n\n今日のテーマは、メルセンヌ・ツイスタ(MT)の性質についてです。\n\nMTの生成する乱数列は、以下の線形漸化式で表わされるのでした。\n\n$$\n\\begin{array}{c}\n\t\\mathbf{x}_{k+n} \\, = \\, \\mathbf{x}_{k+m} \\oplus ( \\mathbf{x}^u_k \\: | \\: \\mathbf{x}^l_{k+1} ) A \\\\\n\t(k = 0,1, \\cdots)\n\\end{array}\n$$\n\n漸化式で表わされるということは、連続した生成された乱数をいくつか集めれば、その次に現れる数値が予測可能じゃないか！？！？！？？\nまた逆に、今まで生成された乱数値も復元できるんじゃないか！？！？？？！\n\nワクワクしますね！\n\n# 打倒Tempering\n\nさて、さっそく……といいたいところですが、そういえば乱数値はTemperingとかいう操作をしてから出力していましたね。\n乱数を予測するには、コイツをどうにかしなければなりません。\n\n前回はTempering行う行列$T$は正則だから逆行列が求まるよね？みたいな話をして終わりました。\n\n以下の様な謎のビット演算が$T$を右から掛けることに相当する、というお話でしたが\nこの$T$がどんな行列なのかを調べることにしましょう。\n\n$$\n\\begin{array}{l}\n\t\\mathbf{y}_1 = \\mathbf{x} \\oplus (\\mathbf{x} \\gg u) \\\\\n\t\\mathbf{y}_2 = \\mathbf{y}_1 \\oplus ((\\mathbf{y}_1 \\ll s) \\: \\& \\: \\mathbf{b}) \\\\\n\t\\mathbf{y}_3 = \\mathbf{y}_2 \\oplus ((\\mathbf{y}_2 \\ll t) \\: \\& \\: \\mathbf{c}) \\\\\n\t\\mathbf{y}_4 = \\mathbf{y}_3 \\oplus (\\mathbf{y}_3 \\gg l)\n\\end{array}\n$$\n\nそういえば前回、何の脈絡もなく整数を各ビットで分けて行ベクトルとしていましたが、\nなんで行ベクトルを考えるのかというと、計算上都合がいいからです。\n例えば、XOR演算はベクトル同士の加算で表現できますし、ビットシフトは適当な正方行列との積で表現できます。\n\nあっ！じゃあ↑の式も一つ一つのビット演算が行列として表せるじゃん！！！\n\n## ビットシフトの行列表現\n\nこれはすぐに思いつきそうです。\n単純に各要素をずらすだけなので、単位行列を列ベクトル分解して、それをずらしたものを掛ければよさそう。\n\n例えば、8ビット整数について2ビットの右シフトを表す行列は以下になります。\n\n$$\nS_8 = \\left(\n\t\\begin{array}{ccccc}\n\t\t0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\n\t\\end{array}\n\\right)\n$$\n\nこの記事中では、$S_n$をビットシフトを表す行列とします\nただし、$n < 0$のとき$|n|$ビット左シフトを、$n > 0$のとき$n$ビット右シフトを表すとします。\n\n## ANDの行列表現\n\nこれは対角成分がAND演算する整数の各ビットの値になった正方行列を考えれば良いです。\n例えば、8ビット整数について`178 = 0b10110010`とのANDを表す行列は以下のように書けます。\n\n$$\nD_{178} = \\left(\n\t\\begin{array}{ccccc}\n\t\t1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\n\t\\end{array}\n\\right)\n$$\n\n対角に`10110010`が現れています。\nなんでコレがAND演算を表すのかは、左から適当な行ベクトルを掛けて、手で計算してみればすぐにわかるはずです。\n\nこの記事中では、$D_n$を$n$とのAND演算を表す行列とします。\n\n## XORの行列表現\n\n`A = 0b1001, B = 0b1001`としたとき、`A xor B`を考えてみます。\n\n| A | B | A xor B |\n|:-:|:-:|:-------:|\n| 1 | 0 |    1    |\n| 0 | 1 |    1    |\n| 0 | 0 |    0    |\n| 1 | 1 |    0    |\n\n各ビットについて見ると、1ビット同士の加算になっています。（桁があふれた分は無視です。）\nということはどうやら、2つの整数のXOR演算は、それら整数を表す行ベクトルを単純に加算するだけで良さそうです。\n\n## Temperingの逆演算\n\nさて、材料は揃いました。\nさっそく、Temperingの逆演算を表す行列を求めるとしましょう。\n\n例のビット演算で書かれた式を行列で表してみます。\n\n$$\n\\begin{array}{l}\n\t\\mathbf{y}_1 = \\mathbf{x} + \\mathbf{x} S_u = \\mathbf{x} (I + S_u) \\\\\n\t\\mathbf{y}_2 = \\mathbf{y}_1  + \\mathbf{y}_1 S_{-s} D_b = \\mathbf{y}_1 ( I + S_{-s} D_b ) \\\\\n\t\\mathbf{y}_3 = \\mathbf{y}_2  + \\mathbf{y}_2 S_{-t} D_c = \\mathbf{y}_2 ( I + S_{-t} D_c ) \\\\\n\t\\mathbf{y}_4 = \\mathbf{y}_3 + \\mathbf{y}_3 S_l = \\mathbf{y}_3 ( I + S_l )\n\\end{array}\n$$\n\nで、式が4本もあると面倒ですし、1つにまとめてしまいましょう。\n\n$$\n\\mathbf{y} = \\mathbf{x} (I + S_u) ( I + S_{-s} D_b ) ( I + S_{-t} D_c ) ( I + S_l )\n\n$$\n\nということで、ようやく$T$の本性が分かりました。\n\n$$\nT = (I + S_u) ( I + S_{-s} D_b ) ( I + S_{-t} D_c ) ( I + S_l )\n\n$$\n\nで、コイツの逆行列$T^{-1}$を求めれば、それがTemperingの逆演算を表す行列です。\n\n# 乱数を予想する\n\nさて、Temperingの逆演算ができれば、話は早いですね！\n\n前回作ったプログラムの _MT内部状態_ を表す配列を、先ほどの手順で復元した値N個で埋めてやれば、\nあとは前回説明した計算方法に従って次に出現する乱数を計算することが出来ます。やった！\n\n# 乱数を復元する\n\nじゃあ、今まで作られたであろう乱数を復元するには？\n\nとりあえず内部状態$\\mathbf{x}$をまず復元しなければならないワケですが、\nMTの漸化式を見ると、$x_k$の上位ビットが$x_{k+n}$の、下位ビットが$x_{k+n-1}$の計算に使われてるなーって気が付くとおもいます。\n\nじゃあ、その計算の逆をやれば、$x_k$が復元できるネ！っていうお話です。\n幸い、漸化式中に現れる演算はさっきやったXOR演算と、既に中身が分かっている行列$A$の乗算だけです！\n\nAはこんな行列なのでした。\n\n$$\nA = \\left(\n\t\\begin{array}{ccccc}\n\t\t0 & 1 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 1 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & \\ddots & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 1 \\\\\n\t\ta_{w-1} & a_{w-2} & \\cdots & \\cdots & a_0\n\t\\end{array}\n\\right)\n$$\n\nこの定義を見ると、$a_{w-1} \\ne 0$ならば明らかに正則ですねコレ。\nMT19937では↑を満たしますし、逆行列も求まりますね！\n\n元の[論文](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf)には、高速に計算するためにこの形にするって書いてあるんですけど、\nコレ正則じゃなくても良いのかな？そうだとすると逆演算ができない？？？（知らない）\n\n# やってみよう！\n\n早速やりましょう。\nとりあえず、前回作ったプログラムで生成した乱数をファイルに書き出して、それを入力して、その部分乱数列から全体を復元しましょう。\n\nはい、やり方はさっきまでさんざん書いたとおりなので、サクッと実装します。\n今回もRubyです。\n\n```ruby\nrequire \"matrix\"\n\n# MT19937\nW = 32\nN = 624\nM = 397\nR = 31\nU = 11\nS = 7\nT = 15\nL = 18\nA = 0x9908B0DF\nB = 0x9D2C5680\nC = 0xEFC60000\n\n# ビットマスク用\nWHOLE_MASK = (\"1\" * W).to_i(2)\nUPPER_MASK = (\"1\" * (W - R) + \"0\" * R).to_i(2)\nLOWER_MASK = (\"0\" * (W - R) + \"1\" * R).to_i(2)\n\n# ビット行列\nclass BitMat < Matrix\n\t# 行ベクトルを整数に\n\tdef to_i\n\t\t# mod 2 しないとダメ\n\t\tself.row(0).to_a.map{|i| i.to_i.abs % 2 }.join.to_i(2)\n\tend\n\t# 整数を行ベクトルに\n\tdef self.from_i(i)\n\t\tself[format(\"%.\" + W.to_s + \"b\", i).split(\"\").map(&:to_i)]\n\tend\n\n\t# kだけビットシフトする演算を表す行列を生成 (k > 0 : 右シフト, k < 0 : 左シフト)\n\tdef self.Shift(k)\n\t\tself[ *(1..W).map{|i| (1..W).map{|j| j == i+k ? 1 : 0 } } ]\n\tend\n\t# kとのAND演算を表す行列を生成\n\tdef self.And(k)\n\t\tself.diagonal(*self.from_i(k).row(0).to_a)\n\tend\n\n\t# r行目を行ベクトルvで置き換え\n\tdef []=(r, v)\n\t\t@rows[r] = v.row(0).to_a\n\tend\nend\n\n########################################\n\n# 行列T\nt = (\n\t(BitMat.I(W) + BitMat.Shift( U)) *\n\t(BitMat.I(W) + BitMat.Shift(-S) * BitMat.And(B)) *\n\t(BitMat.I(W) + BitMat.Shift(-T) * BitMat.And(C)) *\n\t(BitMat.I(W) + BitMat.Shift( L))\n)\n# Tの逆行列\nt_inv = t ** -1\n\n# 行列A\na = BitMat.Shift(1)\na[W-1] = BitMat.from_i(A)\n# Aの逆行列\na_inv = a ** -1\n\n# 乱数列を読み込む\ninput = []\nwhile line = gets\n\tinput.push($1.to_i) if /^\\d+: (\\d+)$/ =~ line\nend\n\n# E番目からN個だけの乱数を使う\nE = input.length / 3\n\nprint \"USE: \" + E.to_s + \" -> \" + (E + N - 1).to_s + \"\\n\";\n\n# E番目～E+N-1番目の乱数を取得し、Temperingの逆演算をする\nxr = input[E, N].map{|e| (BitMat.from_i(e) * t_inv).to_i }\n\n# 内部状態\nx = xr.dup\n\n# E+N番目から順に乱数列を復元\n(E + N).upto(input.length - 1) do |k|\n\ti = (k - E) % N\n\n\t# 乱数を計算\n\tz = x[i] & UPPER_MASK | x[(i + 1) % N] & LOWER_MASK\n\tx[i] = x[(i + M) % N] ^ (BitMat.from_i(z) * a).to_i\n\n\t# Temperingして一致するか確認\n\ty = (BitMat.from_i(x[i]) * t).to_i\n\tif y != input[k]\n\t\tabort \"FAIL: \" + k.to_s + \"\\n\";\n\tend\nend\n\nprint \"RETRIEVED: \" + (E + N).to_s + \" -> \", input.length - 1,\"\\n\";\n\n# 内部状態\nx = xr.dup\n\n# E-1番目から順に0番目までの乱数列を復元\n(E - 1).downto(0) do |k|\n\ti = (k - E) % N\n\n\t# z_i を復元\n\tz = (BitMat.from_i(x[i] ^ x[(i + M) % N]) * a_inv).to_i\n\n\t# z_{i-1} を復元\n\tzp = (BitMat.from_i(x[(i - 1 + N) % N] ^ x[(i - 1 + M) % N]) * a_inv).to_i\n\n\t# z_i, z_{i-1} から x[i] を復元\n\tx[i] = z & UPPER_MASK | zp & LOWER_MASK\n\n\t# Temperingして一致するか確認\n\ty = (BitMat.from_i(x[i]) * t).to_i\n\tif y != input[k]\n\t\tabort \"FAIL: \" + k.to_s + \"\\n\";\n\tend\nend\n\nprint \"RETRIEVED: 0 -> \" + (E - 1).to_s + \"\\n\";\n```\n\n今回は、MTで乱数を生成する際にも行列を用いて計算してみました。なのでとても遅いですね。\n\nちなみに、わざわざ行列を使わなくてもTemperingの逆演算をビット演算で高速に行うことも出来ます。\n\n[メルセンヌ・ツイスタのtemperingの逆関数に関する考察 - Plus Le Blog](http://plusletool.hatenablog.jp/entry/2014/10/24/213816)\n\n# MTはダメ？\n\n_わー！MTで作った乱数は予想・復元されちゃう！危ない！_\n\nというわけではなく、要は適材適所、その性質をよく理解して使うべき、ということでした。\n決して暗号用途に使っちゃダメですよ。（そういうCTF問題がどこかにありましたね……！）\n\n次は **xorshift** を調べてみようかな？\n","title":"メルセンヌ・ツイスタを倒す","image":null,"tags":["CTF","セキュリティ","メルセンヌ・ツイスタ","乱数"],"date":"2016-06-30T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"article","slug":"5","body":"メルセンヌ・ツイスタについて。\n\nメルセンヌ・ツイスタ(MT)は擬似乱数列を作るアルゴリズムの一つで、\n他の手法と比べると欠点が少なくて高品質な擬似乱数列を高速に作れるんだって。スゴイ！\nプログラムをかじった人なら、多分聞いたことがあるんじゃないかと思います。\n\n日本初のアルゴリズムだし、日本語文献あるかな？って思ったんですけど、良い物が見つからなかった（かなしい）ので、\n元の[論文](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf)を読みながらRubyでMTを実装して理解を深めたいと思います。\n\nなんか強いアルゴリズムだ！って聞くとめっちゃ複雑なんじゃないかって思いがちですけど、MTはとっても<span style=\"font-size:1.5em\">**†単純†**</span>です。\n\n# MTの定義\n\n$w$ビットの整数からなる乱数列を生成する場合を考えます。\nこの時、整数を各ビットで分けて$w$次元行ベクトルとして考えることとします。\n\nすると、MTによって生成される乱数列は以下の線形漸化式によって表されます。\n\n$$\n\\begin{array}{c}\n\t\\mathbf{x}_{k+n} \\, = \\, \\mathbf{x}_{k+m} \\oplus ( \\mathbf{x}^u_k \\: | \\: \\mathbf{x}^l_{k+1} ) A \\\\\n\t(k = 0,1, \\cdots)\n\\end{array}\n$$\n\nこの式に登場する$n,m$は定数で、$1 \\le m \\le n$を満たします。\n\n$( \\mathbf{x}^u_k \\: | \\: \\mathbf{x}^l_{k+1} )$は、$\\mathbf{x}_k$の上位$w-r$ビットと$\\mathbf{x}_{k+1}$の下位$r$ビットを連結した行ベクトルを表しています。\nこの$r$も定数で、$0 \\le r \\le w-1$を満たします。\n\n$A$は以下のように定義された$w \\times w$正方行列です。\n\n$$\nA = \\left(\n\t\\begin{array}{ccccc}\n\t\t0 & 1 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 1 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & \\ddots & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 1 \\\\\n\t\ta_{w-1} & a_{w-2} & \\cdots & \\cdots & a_0\n\t\\end{array}\n\\right)\n$$\n\nこれによって、$\\mathbf{x} A$を以下のように高速に計算することができます。\n\n$$\n\\begin{array}{c}\n\t\\mathbf{x} A = \\begin{cases}\n\t\t(\\mathbf{x} \\gg 1) & (x_0 = 0) \\\\\n\t\t(\\mathbf{x} \\gg 1) \\oplus \\mathbf{a} & (x_0 = 1)\n\t\\end{cases} \\\\\n\t\\\\\n\t\\mathbf{x} = (x_{w-1}, x_{w-2}, \\cdots, x_0) \\\\\n\t\\mathbf{a} = (a_{w-1}, a_{w-2}, \\cdots, a_0)\n\\end{array}\n$$\n\nこうして、$w$ビットの整数、もとい$w$次元行ベクトルがたくさんできるわけですが、\nこれをそのまま乱数として出力するのはなんだかマズいらしくて、\n値を程よく分布させるため、出力する行ベクトルに$w \\times w$の適当な**正則行列**$T$を右から掛けます。\n\n$T$を右から掛ける事に相当する演算として、実際には以下の様な演算を行います。\n\n$$\n\\begin{array}{l}\n\t\\mathbf{y}_1 = \\mathbf{x} \\oplus (\\mathbf{x} \\gg u) \\\\\n\t\\mathbf{y}_2 = \\mathbf{y}_1 \\oplus ((\\mathbf{y}_1 \\ll s) \\: \\& \\: \\mathbf{b}) \\\\\n\t\\mathbf{y}_3 = \\mathbf{y}_2 \\oplus ((\\mathbf{y}_2 \\ll t) \\: \\& \\: \\mathbf{c}) \\\\\n\t\\mathbf{y}_4 = \\mathbf{y}_3 \\oplus (\\mathbf{y}_3 \\gg l)\n\\end{array}\n$$\n\n$u,s,t,l$は定数で、&はビットAND演算を表し、$\\mathbf{b}, \\mathbf{c}$は適当な行ベクトルです。\n\nこうして得られた$\\mathbf{y_4}$を出力します。\n（この操作を _Tempering_ と言うそうです。）\n\nで、途中にいろいろ定数やらなんやらが登場したんですが、これらを\n\n$$\n\\begin{array}{l}\n\tw = 32 \\\\\n\tn = 624 \\\\\n\tm = 397 \\\\\n\tr = 31 \\\\\n\tu = 11 \\\\\n\ts = 7 \\\\\n\tt = 15 \\\\\n\tl = 18 \\\\\n\t\\mathbf{a} = \\mathbf{0x9908B0DF} \\\\\n\t\\mathbf{b} = \\mathbf{0x9D2C5680} \\\\\n\t\\mathbf{c} = \\mathbf{0xEFC60000}\n\\end{array}\n$$\n\nとすると、周期が$2^{19937}-1$とめちゃくちゃ長い、かの有名なMT19937になります。\n\n# MTを実装する\n\nなんだか、 _は？_ ってカンジですね！\n\n整理すると、\n\n- 長さnの配列を用意して、適当な値で埋める（これがシード値になります）\n- i番目の乱数を得る\n  - Step.1 `z = x[i] & 0b111..1000..0 | x[(i+1)%n] & 0b000..0111..1` を計算する\n  - Step.2 `x[i] = x[(i+m)%n] ^ (z >> 1) ^ (z & 1 == 0 ? 0 : a)` を計算する\n  - Step.3 Temperingした値を返す\n\nこれだけです。シンプルだ！\n\nStep.1は$( \\mathbf{x}^u_k \\: | \\: \\mathbf{x}^l_{k+1} )$を求めることに相当します。\nStep.2は 最初の漸化式を適用することに相当し、XORで繋がれた後ろの2項は、行列$A$を掛けることに相当します。\n\n自分みたいなプログラマな人間は、たぶんソースコードを見れば一発で理解できるんじゃないかと思います。\nということで、書いてみたのが以下。\n\n```ruby\n# MT19937\nW = 32\nN = 624\nM = 397\nR = 31\nU = 11\nS = 7\nT = 15\nL = 18\nA = 0x9908B0DF\nB = 0x9D2C5680\nC = 0xEFC60000\n\n# ビットマスク用\nWHOLE_MASK = (\"1\" * W).to_i(2)\nUPPER_MASK = (\"1\" * (W - R) + \"0\" * R).to_i(2)\nLOWER_MASK = (\"0\" * (W - R) + \"1\" * R).to_i(2)\n\n# MT乱数列\nclass MT\n\t# seedを受け取って初期化\n\tdef initialize(seed)\n\t\t# MT内部状態\n\t\t@i = 0\n\t\t@x = [seed & WHOLE_MASK]\n\n\t\t# 初期化 (mt19937ar.cに準拠)\n\t\t1.upto(N-1) do |i|\n\t\t\t@x[i] = (1812433253 * (@x[i-1] ^ (@x[i-1] >> 30)) + i) & WHOLE_MASK\n\t\tend\n\tend\n\n\t# MTで乱数を生成\n\tdef next\n\t\t# Step.1\n\t\tz = @x[@i] & UPPER_MASK | @x[(@i + 1) % N] & LOWER_MASK\n\n\t\t# Step.2\n\t\t@x[@i] = @x[(@i + M) % N] ^ (z >> 1) ^ (z & 1 == 0 ? 0 : A)\n\n\t\t# Step.3\n\t\ty = @x[@i]\n\t\ty = y ^ (y >> U)\n\t\ty = y ^ ((y << S) & B)\n\t\ty = y ^ ((y << T) & C)\n\t\ty = y ^ (y >> L)\n\n\t\t# カウンタを変更して、生成した乱数を返す\n\t\t@i = (@i + 1) % N\n\t\treturn y\n\tend\nend\n\n########################################\n\n# 使ってみる\nmt = MT.new(20150919) # ← シード値\n2048.times do |i|\n\tprint i, \": \", mt.next, \"\\n\"\nend\n```\n\n（あんまり自信がないですが、MTの考案者が書いた[C++プログラム](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/CODES/mt19937ar.c)と出力が一致したので、多分大丈夫。）\n\nこうやってみると、本当に**単純**ですね！\nそれでいて性能がたいへんよろしいのですから、スゴイものです。\n\nちなみに↑はもともとPerlで書いてたんですが、諸事情によりRubyで書き直しました。以下はPerl版。\n\n[Perl版](https://gist.github.com/kaz/0bd9bcd72a964864e74fd55bcdfd3117)\n\n# 発展\n\nとりあえずMTがこういうものだって、わかった気になれたわけです。\n個人的には、 _Tempering_ のトコロが面白いと思っていて、ココをもうちょっと掘り下げてみたいと思います。\n\nTemperingは正則行列$T$を右から掛ける演算ですが、\nこの$T$が実際にはどんな行列なのかには、触れませんでした。\n\nでも、正則行列ってことは**逆行列**が存在して、Temperingの逆演算もできて……？\nみたいなお話です。（なんか楽しそうな気がしません？）\n\nということで、次回に続く！！！\n\n[メルセンヌ・ツイスタを倒す](/posts/6/)\n","title":"メルセンヌ・ツイスタをわかった気になる","image":null,"tags":["メルセンヌ・ツイスタ","乱数"],"date":"2016-06-26T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"}]},"__N_SSG":true}