{"pageProps":{"tag":"東北きりたん","entries":[{"type":"article","slug":"18","body":"Win32APIでVOICEROIDをいじってみます\n\n\n# 東北きりたん\n\n[VOICEROID+ 東北きりたん EX](http://www.ah-soft.com/voiceroid/kiritan/)を買いました。\n\nhttp://www.ah-soft.com/voiceroid/kiritan/\n\n![](kiritan.png)\n\nう～～～～んかわいい！！！\nかわいいです。\n\n声もしっとりしていて完全にボク好みです。最高。\n\n# クラウドきりたん\n\nいろいろ使いみちが思いつくんですが、**Windowsでしか動かない**のがネックです……\n\nHTTPでテキストをぶん投げたら音声が飛んでくる感じになったら色々幸せじゃないですか。\nということで作っていきたいと思います。\n\n## Linuxで動かないかな？\n\nLinuxで動かすとすれば、Wineですね。\n\n[Linux の Docker の中で voiceroid+ ゆかりさんを動かす](http://pushl.net/blog/12/)という記事を見つけました。\nどうやらWineで動くみたい？しかもDockerの中で。すごい！\n\nhttp://pushl.net/blog/12/\n\n試してみたんですが、うまくいきませんでした＞＜\n**VOICEROID+ EX**になってからいろいろ変わったんでしょうか。\n\n自分でもWine環境を作って試してみたんですが、 .NET Framework 3.5のインストールがうまく行かず失敗。\n\nということでWineは諦めます。\n\n## WindowsServerで動かないかな？\n\n動作環境には当然乗っていませんが、Windows Server 2016で適当に試してみたら普通に動きました。\n\nですが、VOICEROIDにはGUIしかありません。\nCUIから操作できれば全て解決なんですが、用意されてません。かなしい。\n\nということで、Win32APIを叩いて自作プログラムからVOICEROIDの機能を使えるようにしてみましょう。\nとはいっても、GUIを無理やり操作して動かすだけです。\n筋肉ソリューション感が否めませんが、仕方がないです。\n\n# Win32APIを叩いてVOICEROIDを操作\n\nこのテの話は、「ウィンドウ 操作 Win32API」とかでググると無限に見つかるかと思うので、ザックリとだけ説明します。\n\n`SendMessage`関数を使うとユーザのマウス操作やキーボード操作がエミュレートできるので、\nうまい感じにテキストを入力させて保存ボタンを押させてあげれば、読み上げたwavファイルを得ることができそうです。\n\n## やりました\n\n方針が定まったら書くだけ……\nPythonで書いてみました。\n\nffmpegを使っているので、別途用意が必要です。\n必要なPythonのライブラリは`pypiwin32`です\n\n```sh\npip install pypiwin32\n```\n\n### コード\n\nhttps://github.com/kaz/kiritan-server/blob/aa4c4e4ed39bb024fb50f5392c8375dc4f4fa448/talk.py\n\n```python\n# coding: UTF-8\n\nimport os\nimport sys\nimport time\nimport hashlib\nimport threading\nimport subprocess\n\nfrom win32con import *\nfrom win32gui import *\nfrom win32process import *\n\n# 共通設定\nwaitSec = 0.5\nwindowName = \"VOICEROID＋ 東北きりたん EX\"\n\ndef talk(inputText):\n\t# 出力先ディレクトリ作成\n\toutdir = \"./output/\"\n\ttry:\n\t\tos.mkdir(outdir)\n\texcept:\n\t\tpass\n\n\t# ファイルが存在してたらやめる\n\toutfile = outdir + hashlib.md5(inputText.encode(\"utf-8\")).hexdigest() + \".mp3\"\n\tif os.path.exists(outfile):\n\t\treturn outfile\n\n\t# 一時ファイルが存在している間は待つ\n\ttmpfile = \"tmp.wav\"\n\twhile True:\n\t\tif os.path.exists(outfile):\n\t\t\ttime.sleep(waitSec)\n\t\telse:\n\t\t\tbreak\n\n\twhile True:\n\t\t# VOICEROIDプロセスを探す\n\t\twindow = FindWindow(None, windowName) or FindWindow(None, windowName + \"*\")\n\n\t\t# 見つからなかったらVOICEROIDを起動\n\t\tif window == 0:\n\t\t\tsubprocess.Popen([\"C:\\Program Files (x86)\\AHS\\VOICEROID+\\KiritanEX\\VOICEROID.exe\"])\n\t\t\ttime.sleep(3 * waitSec)\n\t\telse:\n\t\t\tbreak\n\n\twhile True:\n\t\t# ダイアログが出ていたら閉じる\n\t\terrorDialog = FindWindow(None, \"エラー\") or FindWindow(None, \"注意\") or FindWindow(None, \"音声ファイルの保存\")\n\t\tif errorDialog:\n\t\t\tSendMessage(errorDialog, WM_CLOSE, 0, 0)\n\t\t\ttime.sleep(waitSec)\n\t\telse:\n\t\t\tbreak\n\n\t# 最前列に持ってくる\n\tSetWindowPos(window, HWND_TOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE)\n\n\t# 保存ダイアログの操作\n\tdef enumDialogCallback(hwnd, param):\n\t\tclassName = GetClassName(hwnd)\n\t\twinText = GetWindowText(hwnd)\n\n\t\t# ファイル名を設定\n\t\tif className.count(\"Edit\"):\n\t\t\tSendMessage(hwnd, WM_SETTEXT, 0, tmpfile)\n\n\t\t# 保存する\n\t\tif winText.count(\"保存\"):\n\t\t\tSendMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, 0)\n\t\t\tSendMessage(hwnd, WM_LBUTTONUP, 0, 0)\n\n\t# 音声の保存\n\tdef save():\n\t\ttime.sleep(waitSec)\n\n\t\t# ダイアログがあれば操作する\n\t\tdialog = FindWindow(None, \"音声ファイルの保存\")\n\t\tif dialog:\n\t\t\tEnumChildWindows(dialog, enumDialogCallback, None)\n\t\t\treturn\n\n\t\t# 再試行\n\t\tsave()\n\n\t# VOICEROIDを操作\n\tdef enumCallback(hwnd, param):\n\t\tclassName = GetClassName(hwnd)\n\t\twinText = GetWindowText(hwnd)\n\n\t\t# テキストを入力する\n\t\tif className.count(\"RichEdit20W\"):\n\t\t\tSendMessage(hwnd, WM_SETTEXT, 0, inputText)\n\n\t\tif winText.count(\"音声保存\"):\n\t\t\t# 最小化解除\n\t\t\tShowWindow(window, SW_SHOWNORMAL)\n\n\t\t\t# 保存ダイアログ操作用スレッド起動\n\t\t\tthreading.Thread(target=save).start()\n\n\t\t\t# 保存ボタンを押す\n\t\t\tSendMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, 0)\n\t\t\tSendMessage(hwnd, WM_LBUTTONUP, 0, 0)\n\n\t# VOICEROIDにテキストを読ませる\n\tEnumChildWindows(window, enumCallback, None)\n\n\t# プログレスダイアログが表示されている間は待つ\n\twhile True:\n\t\tif FindWindow(None, \"音声保存\"):\n\t\t\ttime.sleep(waitSec)\n\t\telse:\n\t\t\tbreak\n\n\t# MP3に変換\n\tsubprocess.run([\"ffmpeg\", \"-i\", tmpfile, \"-acodec\", \"libmp3lame\", \"-ab\", \"128k\", \"-ac\", \"2\", \"-ar\", \"44100\", outfile])\n\n\t# 一時ファイルが存在していたら消す\n\ttry:\n\t\tos.remove(tmpfile)\n\t\tos.remove(tmpfile.replace(\"wav\", \"txt\"))\n\texcept:\n\t\tpass\n\n\treturn outfile\n\nprint(talk(sys.argv[1]))\n```\n\n## 注意\n\n一度適当なテキストを読み上げさせ、スクリプトを実行するディレクトリに保存させておく必要があります。\n保存先ダイアログを操作するときに、保存先ディレクトリを変更せずに保存させるため、\nスクリプトの実行ディレクトリと同じところがデフォルトになっていないと以後の処理が失敗します。\n\n手抜きです……\n\n## ハマりそうなポイント\n\n- ところどころにsleepを入れないと操作が失敗することがある\n- フォーカスが当たってないとか最小化されてるとかでボタン操作に失敗することがある\n- 出力が終わってない状況で新しい読み上げをさせようとすると死ぬ\n\t- 今回は前のが終わるまでブロックするようにした\n- Windowsのバージョンが違うと保存ウィンドウが違う気がするので上手く行かないかも\n\t- 今回はWindowsServer2016(Windows 10)です\n- 同じテキストの繰り返しを投げるとVOICEROIDがエラーを吐く\n\t- よくわからん\n\n# 次回予告\n\nということで、Pythonから好きなテキストをVOICEROIDに送って読み上げたWAVを得ることができるようになりました。\nコレだけでもうだいぶ夢が広がるカンジですね！！\n\n次回は、コイツをクラウドで動かしていつでもどこでもきりたんボイスが作れる環境を作ります。\n\n[クラウド東北きりたん その2 ～AzureのWindowsServerでVOICEROIDを動かす～](/posts/19/)\n","title":"クラウド東北きりたん その1 ～Win32APIでVOICEROIDを操作～","image":null,"tags":["VOICEROID","東北きりたん","Win32API","Python"],"date":"2017-05-25T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"article","slug":"19","body":"AzureのWindowsServerでVOICEROIDを動かします\n\n[前回](/posts/18/)の続きです。\n\n# あらすじ\n\n前回はPythonからWin32APIをバシバシ叩いてきりたん好きなコトを喋らせることができるようになったのでした。\n\n[クラウド東北きりたん その1 ～Win32APIでVOICEROIDを操作～](/posts/18/)\n\n今回は、クラウドサービス上（というか適当なサーバ）できりたんに働いてもらおうと思います。\n\n![](kiritan.png)\n\n# Microsoft Azure\n\nMicrosoft AzureのVirtual Machinesでは、WindowsServerのインスタンスを立ち上げることが出来ます。\nそのへんのWindows VPSサービスを比べるとちょっと割高な感じはします。（それはそう）\n\nなんかAzureではWindows Client（普通のWindows 10とか）も使えるっぽいんですが、\nMSDNサブスクリプションが必要とかでアレなので、今回はWindowsServerで行きます。\n\nぶっちゃけKVMベースのVPSサービスならWindowsが普通にインストールできるような気がしますが、\n契約関係で怖い人から怒られるので避けるのが無難です。\n\n~~学生なら、Microsoft Imagine(旧Dreamspark)からWindows Sever 2016のライセンスがタダでもらえるので、コレを使って自宅鯖を建てるのもアリかと思います。~~[^imagine]\n\n[^imagine]: Microsoft Imagineは終了したらしいです。\n\n## インスタンス作成\n\nAzure Portalから適当にインスタンスを作ります。\nインスタンスのサイズですが、メモリ0.75GBだとかなり厳しさがあるので1.75GBが最低ラインな感じがあります。\n\nあと、デフォルトだと鬼高いサイズしか表示されなくて焦るんですが、\n**サポートされるディスクの種類**を**SSD**にして、**全て表示**を押すとお手頃サイズが出てきます。\n\n![](1.png)\n\nボクは無料試用クレジットを使い切るために強めのインスタンスを建てました。\n\nインスタンスを作成したときに勝手に**ネットワークセキュリティグループ**というリソースが作成されており、\nこの設定を変えてポートを開けないとリモートデスクトップ接続(RDP)ができません。\n\n対象のネットワークセキュリティグループを開いて、**受信セキュリティ規則 → 追加**で設定画面を開き、\nサービスから**RDP**を選択して許可します。\n\n![](2.png)\n![](3.png)\n\nこのあとHTTPも使うので、ついでにHTTPを許可する設定も追加しておきましょう。\n先程と同様にして設定画面を開き、サービスから**HTTP**を選択して許可します。\n\n# サーバ設定\n\nWindowsServerを使う場合は、いろいろ設定が必要になります。\n普通のWindowsを使う場合は不要なものも多いので、軽く目を通す程度で。\n\n## RDP\n\nリモートデスクトップ接続(RDP)を使ったほうが色々便利なので、そうします。\nAzureだと、勝手にONになっているのでこの設定は不要です。\n\nサーバマネージャを起動して、**ローカルサーバ → リモートデスクトップ → このコンピュータへのリモート接続を許可する**にチェックを入れてOKを押します。\n\n![](4.png)\n\n## .NET Framework\n\n普通のWindowsだと必要になったときにダイアログが出てきて簡単にインストールできますが、\nWindowsServerだとそうはいきません。\n\nサーバマネージャを起動して、**管理 → 役割と機能の追加 → .NET Framework 3.5 Features**にチェックを入れてインストールします。\n\n![](5.png)\n\n## ファイアウォール\n\nこのあとHTTPをきりたんと通信するインタフェースとして使うので、`80/tcp`を開放します。\n\nサーバマネージャを起動して、**ローカルサーバ → Windowsファイアウォール → 詳細設定 → 受信の規則 → 新しい規則**\nで出てくるダイアログに従って、80番ポートを開放します。\n\n![](6.png)\n\n## IEの制限解除\n\nWindowsServerではデフォルトでIEが機能制限されているので、解除します。\nこの後Pythonをインストールしたりするときに問題があるためです。\n\nサーバマネージャを起動して、**ローカルサーバ → IEセキュティ強化の構成 → Administratorsグループ → オフ**にチェックを入れてOKを押します。\n今回はいろいろラクをするためにAdministratorで進めていきますが、一般ユーザで行う場合はUsersグループのセキュティ強化の構成をオフにしてください。\n\n![](7.png)\n\n# VOICEROIDのインストール\n\n普通にインストーラからインストールできます。\n1ライセンスで1PCにしかインストール出来ないので、注意しましょう。\n\n## ライセンス認証\n\nサーバ起動後、一度でもRDPで接続していると**ライセンス認証に失敗**するようになります。\n多分、ライセンス認証ドライバ（Sentinel LDK License Manager）がRDPを検知して爆発してるからです。\nRDPで繋ぐような環境で使うな！！！ってことっぽいのでちょっとグレーかもしれません……\n\n回避策として、RDPで繋ぐ前にきりたんを起動してしまいます。\n\n- 起動時に自動ログインさせる\n- ログイン時にきりたんを自動起動する\n\n`HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon`に以下の3つのキーを作成します。\n\n- AutoAdminLogon\n\t- DWORDで値は`1`\n- DefaultUserName\n\t- ログインするユーザ名\n- DefaultPassword\n\t- ログインユーザのパスワード\n\n![](8.png)\n\nこれで、起動時に勝手にログインするようになります。\n\n次に、スタートメニューを出して`gpedit.msc`を入力してエンターし、\n**ユーザの構成 → Windowsの設定 → スクリプト → ログオン**を開き、\nVOICEROIDのEXEファイルを指定します。\n\n![](9.png)\n\nこれで、ログイン後に自動でVOICEROIDが起動します。\n\nこれによって、サーバ起動時に勝手にログインしてきりたんが立ち上がります。\nかなり筋肉ソリューション感が強いですが、仕方がない＞＜\n\n## 起動時のエラー\n\nAzure上だとサウンドデバイスがないので、起動時にエラーが表示され、再生ボタンが押せなくなります。\n音声保存はできるので、今回は問題ありません。\n\n# PythonでVOICEROIDをサーバ化\n\n[前回](/posts/18/)PythonからVOICEROIDを操作できるようになったので、\nあとはHTTPからリクエストを受けて音声ファイルを返すようにするだけです。\n\nサーバへPythonとFFMPEGをインストールしておきましょう。\nGUIがあるので普通にやるだけです。かんたん。\n\n## やりました\n\n方針が定まったら書くだけ……\nflaskを使って書きました。\n\nVOICEROID操作のコードは[前回](/posts/18/)の記事を参照してください。\n\nffmpegを使っているので、別途用意が必要です。\n必要なPythonのライブラリは`pypiwin32`と`flask`です\n\n```sh\npip install pypiwin32 flask\n```\n\n### コード\n\nhttps://github.com/kaz/kiritan-server/blob/aa4c4e4ed39bb024fb50f5392c8375dc4f4fa448/server.py\n\n```python\n# coding: UTF-8\n\nimport flask\nimport subprocess\n\napp = flask.Flask(__name__)\n\n@app.route('/', methods=['GET', 'POST'])\ndef get():\n\tr = flask.request\n\ttext = r.form['text'] if r.method == \"POST\" else r.args.get('text', None)\n\n\tif text == None:\n\t\treturn 'plz specify `text`'\n\n\tcompleted = subprocess.run(\n\t\t['python', 'talk.py', text],\n\t\tencoding='ascii',\n\t\tstdout=subprocess.PIPE,\n\t\ttimeout=30\n\t)\n\n\treturn flask.send_from_directory('./', completed.stdout.strip())\n\nif __name__ == '__main__':\n\tapp.debug = True\n\tapp.run(host='0.0.0.0', port=80)\n```\n\n## 注意\n\n一度適当なテキストを読み上げさせ、スクリプトを実行するディレクトリに保存させておく必要があります。\n保存先ダイアログを操作するときに、保存先ディレクトリを変更せずに保存させるため、\nスクリプトの実行ディレクトリと同じところがデフォルトになっていないと以後の処理が失敗します。\n\n手抜きです……\n\n# 次回予告\n\nということで、HTTPで好きなテキストをVOICEROIDに送って読み上げたWAVを得ることができるようになりました。\nコレでブラウザさえあればきりたんボイスが聴けてしまうわけです。ああ＾～きりたんかわいい！！！！\n\n次回は、コイツを更に改造してきりたんボイスをライブストリーミングしてみる実験です。\n\n[クラウド東北きりたん その3 ～HLSでライブストリーミング～](/posts/20/)\n","title":"クラウド東北きりたん その2 ～AzureのWindowsServerでVOICEROIDを動かす～","image":null,"tags":["VOICEROID","東北きりたん","クラウド","Azure","WindowsServer"],"date":"2017-05-25T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"article","slug":"20","body":"HLSを使ったライブストリーミングを試してみます\n\n[前々回](/posts/18/)・[前回](/posts/19/)の続きです。\n\n<!--more-->\n\n# あらすじ\n\n前々回はPythonからWin32APIをバシバシ叩いてきりたん好きなコトを喋らせることができるようになったのでした。\n\n[クラウド東北きりたん その1 ～Win32APIでVOICEROIDを操作～](/posts/18/)\n\n前回はAzureのWindowsServerにHTTPリクエストを送ってきりたん好きなコトを喋らせるサーバができたのでした。\n\n[クラウド東北きりたん その2 ～AzureのWindowsServerでVOICEROIDを動かす～](/posts/19/)\n\n今回は、**HTTP Live Streaming**(HLS)を用いてきりたんボイスをライブ配信してみようと思います！\n\n![](kiritan.png)\n\n# HTTP Live Streaming\n\n**HTTP Live Streaming**とは、Appleが開発したHTTPベースのストリーミング配信プロトコルです。\n静的な動画ファイルのストリーミング配信はもちろん、ライブ配信(生放送)もできたり、\nアダプティブストリーミングと呼ばれる回線速度に応じて配信するビットレートを変更する技術も利用可能です。\n\n最近話題の[AbemaTV](https://abema.tv/)なんかでも、HLSで配信を行っています。\nちなみに、Twitterにアップされた動画もHLSで配信されています。\n\nストリーミング配信プロトコルと聞くと、複雑そうな気がしてきますが、HLSはHTTPベースで非常に単純です。\nザックリと説明を書いてみます。\n\n## HLSのしくみ\n\nHLSでの配信は、`.ts`ファイルと`.m3u8`ファイルによって行われます。\n\n### ts\n\n`.ts`ファイルは、**MPEG-2 TS**と呼ばれる形式で、配信される映像・音声そのものが格納されます。\n\n配信されるデータは一定の秒数ごとに分割し、このMPEG-2 TS形式で保存しておきます。\n分割された`.ts`ファイルは、HTTPでダウンロードできるようにしておきます。\n\nちなみに、日本のデジタルテレビ放送もこのMPEG-2 TSで配信されています。\n\n### m3u8\n\n`.m3u8`ファイルは、配信ファイルのインデックスです。\n先述した`.ts`に分割された映像・音声データのURLが列記されています。\n\nAbemaTVから配信されている`.m3u8`の例\n```\n#EXTM3U\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=300000\n240/playlist.m3u8?t=3i87VhR5nuXMsjxJRGBiEYSNPdfggGQtr9LjXNx1fr5Dufac7cEaEKMyo2UAv77B63hAvVewach5eaPjFGK3EU22fcpcFD4RAeNAE7nisDwZguUqvp&mq=720&lanceId=c99528aa-0c3c-4987-ab6c-ce5cd1430223\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=900000\n360/playlist.m3u8?t=3i87VhR5nuXMsjxJRGBiEYSNPdfggGQtr9LjXNx1fr5Dufac7cEaEKMyo2UAv77B63hAvVewach5eaPjFGK3EU22fcpcFD4RAeNAE7nisDwZguUqvp&mq=720&lanceId=c99528aa-0c3c-4987-ab6c-ce5cd1430223\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1400000\n480/playlist.m3u8?t=3i87VhR5nuXMsjxJRGBiEYSNPdfggGQtr9LjXNx1fr5Dufac7cEaEKMyo2UAv77B63hAvVewach5eaPjFGK3EU22fcpcFD4RAeNAE7nisDwZguUqvp&mq=720&lanceId=c99528aa-0c3c-4987-ab6c-ce5cd1430223\n#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=2200000\n720/playlist.m3u8?t=3i87VhR5nuXMsjxJRGBiEYSNPdfggGQtr9LjXNx1fr5Dufac7cEaEKMyo2UAv77B63hAvVewach5eaPjFGK3EU22fcpcFD4RAeNAE7nisDwZguUqvp&mq=720&lanceId=c99528aa-0c3c-4987-ab6c-ce5cd1430223\n```\n\nこれはMaster Playlistと呼ばれるデータで、\n回線速度によって異なるビットレートでの配信を行うアダプティブストリーミングのためのファイルです。\n次に示すMedia PlaylistのURLと想定する回線速度が列記されています。\n\nAbemaTVから配信されている`.m3u8`の例\n```\n#EXTM3U\n#EXT-X-VERSION:3\n#EXT-X-TARGETDURATION:6\n#EXT-X-MEDIA-SEQUENCE:4\n#EXT-X-DISCONTINUITY-SEQUENCE:1\n#EXT-X-KEY:METHOD=AES-128,URI=\"abematv://v2/abema-news/abema-news/DUjoiyL1pJGkADZotyiXDn5\",IV=0xaccca4b41de3d9afb029070eb564be40\n#EXTINF:5.005000,\nhttps://abematv.akamaized.net/tsnews/abema-news/h264/720/5BPWe1D8Hu9yCC8HaA3oHS.ts\n#EXTINF:5.005000,\nhttps://abematv.akamaized.net/tsnews/abema-news/h264/720/5SphyMY1TTLvYkFo7B5JuM.ts\n#EXTINF:5.005000,\nhttps://abematv.akamaized.net/tsnews/abema-news/h264/720/2kxyGFo9sH9zUUfKj5USUk.ts\n#EXTINF:5.005000,\nhttps://abematv.akamaized.net/tsnews/abema-news/h264/720/Cz43TVWLgUgqskzvWBBnjA.ts\n```\n\nこれはMedia Playlistと呼ばれるデータで、\n配信されている映像・音声が格納された`.ts`ファイルのURLが列記されています。\n\n### 再生の方法\n\nクライアントは、まず`.m3u8`ファイルを取得します。\nそれがMaster Playlistであれば、回線速度によって適切な`.m3u8`を読みに行きます。\nそれがMedia Playlistであれば、`.ts`ファイルを取得して再生します。\n\nクライアントは、`.m3u8`内のタグと呼ばれるデータ(`#EXT`で始まる行)に従って、`.m3u8`を再読込します。\nライブ配信を行う場合は、クライアントが再読込した際に新しい配信データが追加されていれば良いわけです。\n\n以下に、主要なタグの説明を示します。\n\n#### EXT-X-TARGETDURATION\n\n分割された`.ts`の中で最大の長さに最も近い整数値を指定します。\nクライアントは、およそこの秒数ごとに`.m3u8`を再読込します。\n\nhttps://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1\n\n#### EXT-X-MEDIA-SEQUENCE\n\nその`.m3u8`にかかれている一番最初の`.ts`が、放送全体で何番目の`.ts`であるかの値を指定します。\nクライアントが分割された`.ts`を正しく連続再生する上で必要になります。\n\nhttps://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.2\n\n#### EXTINF\n\n分割された`.ts`１つの秒数。小数で指定できる。\n\nhttps://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.2.1\n\n# HLSを再生したい\n\nHLSはブラウザ上で再生できるのが強いです。\nhttps://caniuse.com/#search=HLS\n\nん？？？？？なんか赤いな……\n\n![](hls.png)\n\nFirefoxとChromeが対応してないやんけ！！！！！！！！！\n珍しくEdgeが優秀だ……\n\n悲しいですね。\nでも**Mesia Source Extensions**(MSE)という機能を使うとそれっぽくHLSを再生できるので安心です。\nhttps://caniuse.com/#search=MSE\n\nMSEを使ったHLS再生は、[Video.js](http://videojs.com/)とか[hls.js](https://github.com/video-dev/hls.js/tree/master)とかのライブラリを使うと簡単です。\n\nちなみに、AbemaTVは[THEOplayer](https://www.theoplayer.com/)という有償のプレーヤーを使ってるみたい。\n\n# HLSで生配信\n\nHLSをなんとな～くわかった気になったので、ライブ配信をやってみます。\n\nHLSで生配信をするにはどうすればよいのかというと、つまり\n\n- データをMPEG-2 TSにエンコードする\n- `.m3u8`に`.ts`へのリンクを追加する\n\nを繰り返すだけです。\n\n`.ts`へのを追加していくだけだとドンドン`.m3u8`がでっかくなってしまうので、\n過去の`.ts`へのリンクはある程度時間が立ったら消してしまいましょう。\n`.ts`へのリンクを消したら、`#EXT-X-MEDIA-SEQUENCE`を増やさないとクライアントが困ってしまうので注意です。\n\nとっても単純ですね！\nさて、先述したことをやるだけでライブ配信サーバが書けてしまいます。\n\n今回は、Twitterからタイムラインを取得して、ツイートをいい感じにきりたんに読んでもらい、\nHLSを用いてリアルタイムでその音声データを配信してみます。\n\n音声ファイルを分割してMPEG-2 TSにするのを自分で書くのは流石にしんどいので、\nFFMPEGさんにお願いしました。\nhttps://www.ffmpeg.org/ffmpeg-formats.html#hls-1\n\n## やること\n\n![](system.svg)\n\n### twitter.listen()\n\n- UserStreamでツイート取得\n- kiritan.pyにジョブを投げる\n- encoder.pyのキューに読み上げたWAVファイルを蓄積\n\n### encoder.livestreaming()\n\n- キューにファイルがなければ無音データをプレイリストに追加\n- キューにファイルがあればTSに分割してプレイリストに追加\n- プレイリストの先頭のTSの再生時間分だけ待って、プレイリストから削除\n\n## やりました\n\n方針が定まったら書くだけ……\n\n### コード\n\n全コード\n\nhttps://github.com/kaz/kiritan-server\n\nHLS関係の処理はたったコレだけです！\n```python\n# FFMPEGでファイルをMPEG-TSにエンコード（中身はMP3）\ndef ts(file):\n\tlogging.info(\"Encoding WAV to MPEG-TS\")\n\n\tdata = subprocess.run(\n\t\t[\n\t\t\t\"ffmpeg\",\n\t\t\t\"-i\", file, \"-vn\",\n\t\t\t\"-acodec\", \"libmp3lame\",\n\t\t\t\"-ab\", \"128k\",\n\t\t\t\"-ac\", \"2\",\n\t\t\t\"-ar\", \"44100\",\n\t\t\t\"-f\", \"hls\",\n\t\t\t\"-hls_time\", \"2\",\n\t\t\t\"-hls_list_size\", \"0\",\n\t\t\t\"-start_number\", str(int(time.time() * 1000)),\n\t\t\t\"-hls_segment_filename\", \"static/live%d.ts\",\n\t\t\t\"pipe:1.m3u8\"\n\t\t],\n\t\tstdout=subprocess.PIPE,\n\t\tstderr=subprocess.DEVNULL\n\t)\n\n\t# 出力されたプレイリストをパースして返す\n\tplaylist = data.stdout.decode(\"utf-8\")\n\tplaylist = playlist[playlist.rfind(\"#EXTM3U\"):]\n\n\t# Tuple (再生時間, ファイルパス)\n\treturn re.findall(r\"#EXTINF:([\\d.]+),\\s+(\\S+)\", playlist)\n\n# ライブストリーミングキューに追加\nque = []\ndef enqueue(f):\n\tque.append(f)\n\n# ライブプレイリストを更新\ntsl = []\nseq = 0\ndef __livecasting():\n\tglobal seq\n\n\twhile True:\n\t\ttry:\n\t\t\tif len(que) != 0:\n\t\t\t\t# キューにデータがあればプレイリストに追加\n\t\t\t\ttsl.extend(ts(que.pop(0)))\n\t\t\telse:\n\t\t\t\t# キューが空なら無音ファイルを配信\n\t\t\t\twhile len(tsl) < 3:\n\t\t\t\t\ttsl.append((\"2.04\", \"silent.ts\"))\n\n\t\t\t# TS 1つ分だけ休憩する\n\t\t\ttime.sleep(float(tsl[0][0]))\n\t\t\ttsl.pop(0)\n\t\t\tseq += 1\n\t\texcept:\n\t\t\tlogging.error(traceback.format_exc())\n\n# サーバ起動\ndef livecasting():\n\t# 古い配信データを削除\n\tfor f in glob.glob(\"static/live*\"):\n\t\tos.remove(f)\n\n\tthreading.Thread(target=__livecasting).start()\n\n# ライブプレイリストを生成\ndef playlist():\n\tpl = [\n\t\t\"#EXTM3U\",\n\t\t\"#EXT-X-VERSION:3\",\n\t\t\"#EXT-X-TARGETDURATION:3\",\n\t\t\"#EXT-X-MEDIA-SEQUENCE:%d\" % seq\n\t]\n\n\tfor ts in tsl[:5]:\n\t\tpl.append(\"#EXTINF:%s,\" % ts[0])\n\t\tpl.append(\"#EXT-X-DISCONTINUITY\")\n\t\tpl.append(\"/static/%s\" % ts[1])\n\n\treturn \"\\n\".join(pl)\n```\n\nffmpegを使っているので、別途用意が必要です。\n必要なPythonのライブラリは`pypiwin32`と`flask`と`tweepy`です\n\n```sh\npip install pypiwin32 flask tweepy\n```\n\n## 動作検証\n\n大体のブラウザでhls.jsを介した再生ができました。\n\nネイティブでHLSに対応しているブラウザ(Safari, Edge, iOS Safari, Android Chrome)は、\n`.m3u8`に直接アクセスしても再生できました。\n\nなんかAndroidだとちょっとプツプツしちゃってるかも？？？\n\n## ハマりそうなポイント\n\n- TS1つの長さ、プレイリスト全体の長さ、`#EXT-X-TARGETDURATION`をうまく調整しないと再生されなかったりプツプツなったりする\n\t- このへんどうするのが最適なのかがわからないので今回は試行錯誤した\n- TSが切り替わる（別のメディアから生成したものになる）時に`#EXT-X-DISCONTINUITY`を付けないと再生が止まる\n\t- Appleのソフトウェアはうまくやってくれるけど、その他は上手く行かない\n- TwitterのUserStreamはPCの時計かズレてると認証失敗する\n\n# おしまい\n\nということで、AzureのWindowsServerでWin32APIを使ってVOICEROIDを操作してTwitterのTLを読み上げた音声をHLSでライブ配信できました！\n\nWin32APIとかHLSとか、まだわからないことがたくさんなので、それはおかしいだろ！って思ったら鉞おねがいします＞＜\n\nそれにしても、きりたんはかわいいですね！\n\nおしまい\n","title":"クラウド東北きりたん その3 ～HLSでライブストリーミング～","image":null,"tags":["HLS","VOICEROID","インフラ","ストリーミング","東北きりたん"],"date":"2017-05-25T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"}]},"__N_SSG":true}