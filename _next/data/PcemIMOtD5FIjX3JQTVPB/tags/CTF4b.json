{"pageProps":{"tag":"CTF4b","entries":[{"type":"article","slug":"13","body":"行きました\n\n東京から参りました成瀬順と申します。\n\nCTF4b東京は大人気だったらしく行けなかったので、金沢へ参加しました。\n\n# Web\n\n- ChromeのDevToolsの使い方\n- ディレクトリトラバーサル\n- SQLインジェクション\n- XSS(の紹介だけ)\n\n演習中心で、実際にやってみよう！って感じなので楽しくて分かりやすかったです。\n\nあとディレクトリトラバーサルとかSQLインジェクションの演習になんか隠しFLAGみたいなものが置いてあって、\n†ビギナー†の人も楽しめそうでした。\n\nSQLiの方の隠しFLAGは見つけられました\n`web4b{can_access_another_table}`\n\n# Forensics\n\n- Forensicsとは\n- ネットワークについて\n- ツールの使い方\n  - Wireshark\n  - binwalk\n  - exiftool\n  - The Sleuth Kit\n\nForensicsは全く知識がなかったので色々勉強になりました。\nWiresharkの便利な機能をたくさん知れたので強くなった気がします💪\n\n# Reversing\n\n- プログラム実行の仕組み\n- x86アセンブリ入門\n\nちょうど大学でx86を勉強したところだったので、なんとかついていけました。\n**上達のコツ**はたくさん読むことだそうです（がんばります＞＜）\n\n# CTF\n\n講義で学んだことを活かしてみよう！というやつです。\n\nがんばって全部解きました！\n\n![](1.png)\n\nhttps://twitter.com/ctf4b/status/802446106776850432\n\nFLAGためて10分前にまとめて出してみました。\nいわゆるサブマリン戦法です。（一度やってみたかったんです＞＜）\n\n以下Writeup\n\n\n## Warmup (Misc 10)\n\nやるだけ\n\n## てけいさん for ビギナーズ (Misc 200)\n\nめっちゃ簡単な計算問題が100問出されるので全部解いてねって問題でした。\n与えられたURLにアクセスすると計算式が書いてあって、その下にあるフォームに値を入力してSubmitするようになってます。\nたぶんPHPのSESSIONで何問解いたかをカウントしてるので、ここはどうにもできなさそうです。\n\n最初ふつうに100問解こうかなと思ったんだけど間違えたらリセットされるみたいなのでやめました。\n\nJavaScriptを書いて(Web講義で習ったDevToolsを使って)100回走らせました。\n\n```javascript\ndocument.querySelector(\"input[type=text]\").value = eval(document.querySelector(\"div\").textContent);\ndocument.querySelector(\"input[type=submit]\").click();\n```\n\n模範解答はPython(?)でやってたけどスクレイピングして……とかが面倒そうでした。\n\n## CountUp Game (Misc 200)\n\n> 交互にカウントアップしていこう ただし，21を言ってはいけません\n\nコンピュータと交互に1〜3づつ値を増やしていって、21を踏んだら負けるゲームを10連勝してねって問題でした。\nなんか競プロでありそうな問題ですね。\n\nそんなに難しくなくて、自分が必ず後攻なので、自分が必ず4の倍数を踏むようにしていれば勝てます。\nたった10勝でOKなので、手でやりました。\n\n## Fix it (Web 100)\n\n> ページ遷移を行うプログラムを書いたが何かを間違っているらしく正常に動作しないそうだ。何がおかしいのか調べてほしい。\n\n講義でやったやつだ！\n\n送られてくるヘッダをよく見てみると、\n`Locatin: /web100/flag_is_here.php`\nTypoしてます。\n\nということで、このURLにに行くとFlagが落ちてました。\n\n## Login as Admin (Web 200)\n\nこれも講義でやったやつだ！\n\nSQLインジェクションっぽいですね。\nので、\n```\nusername: admin\npassword: ' OR 1 --\n```\nとかしてみたらイケました。\n\n## 1M4G3 V13W3R (Web 200)\n\n画像アップローダです。\nアップされた画像を開いてみると、URLが`/web200-2/view.php?file=f5b5a9b812d45f55.jpg`とかで、怪しい。\n\n講義でやったディレクトリトラバーサルかな！？\n\nじゃあ`/web200-2/view.php?file=../index.php`とかすると、\nPHPコメントでFlagが書いてありました。\n\n## Login Lv2 (Web 300)\n\nまたログインフォームです。\n普通にSQLインジェクションを試行するんですが、どうも上手く行かないようです。\n（でもエラーにはなります。うーん？）\n\n適当にログインを試行していると、「ユーザー名かパスワードが間違っています。」と怒られるんですけど、\nこのときのURLが`/web300/index.php?error=invalid_user.txt`とかなってて、アレかなってなりました。\n\nということで、POSTリクエストの宛先である`/web300/index.php?error=login.php`を見てみると、\n```php\n$sql = \"SELECT username, password FROM users WHERE username = ('{$username}') AND password = ('{$password}');\";\n```\n\nカッコで囲んでいたんですね！\nじゃあこうすれば……\n```\nusername: admin\npassword: ') OR 1 --\n```\nイケました。\n\n## FileSystem (Forensics 100)\n\n謎のファイルが渡されます。\n（なんのファイルかは問題名から察せそうですけど、）とりあえず講義で学んだように、どんなファイルであるかを調べてみます。\n\n```sh\n# file for100\nfor100: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID \"mkfs.fat\", sectors/cluster 4, root entries 512, sectors 8192 (volumes <=32 MB) , Media descriptor 0xf8, sectors/FAT 6, sectors/track 32, heads 64, serial number 0x742adb6b, unlabeled, FAT (12 bit)\n```\n\nFATですね。\nではでは、講義で習ったThe Sleuth Kitを使ってみます。\n\n```sh\n# fls for100\nr/r 4:   flag.txt\nr/r * 6: .flag.txt.swp\nv/v 130867: $MBR\nv/v 130868: $FAT1\nv/v 130869: $FAT2\nd/d 130870: $OrphanFiles\n```\n\nありますね！\n\n```sh\n# icat for100 4\nctf4b{\n```\n\n消えてる……\n\nここで削除済みの`.flag.txt.swp`に注目します。\nこのファイルはvimが編集履歴を保持しておくファイルで、通常はファイルが保存されたらこのswpは削除されます。\n\nでもこのイメージにはバッチリ(削除済みファイルとして)残ってるので、\n\n```sh\n# icat for100 6\nU3210#\"! Utpad????ctf4b{ff97e486da08bfec774688ca3ef6ac42}\n```\n\n### ラクをする\n\n問題名から察するに、講義で紹介したThe Sleuth Kitを使ってなんかしてね！って問題なんだろうなって思ったんですけど、\nstringsでゴリ押してしまいました＞＜\n\n```sh\nstrings for100 | grep ctf4b{\n```\n\n## みてみよう (Forensics 200)\n\npcapファイルが渡されます。\n\nそんなにリクエスト数が多くなくて、PNGをダウンロードしてるHTTP通信が１つだけです。\n授業で習ったように、ファイル＞オブジェクトをエクスポートでこのPNGをファイルを取り出してみます。\n\nそうするとただの真っ白な画像ファイルでした。（困った……）\nここで、講義で習ったbinwalkを使ってみます。\n\n```sh\n# binwalk flag.png\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n0             0x0             PNG image, 320 x 240, 8-bit/color RGB, non-interlaced\n41            0x29            Zlib compressed data, best compression\n744           0x2E8           Unix path: /www.w3.org/1999/02/22-rdf-syntax-ns#'>\n```\n\nなんかRDFのデータがくっついてますね。\nじゃあ、講義で習ったexiftoolを使ってみます。\n\n```sh\n# exiftool flag.png\nExifTool Version Number         : 10.20\nFile Name                       : flag.png\nDirectory                       : ..\nFile Size                       : 1010 bytes\nFile Modification Date/Time     : 2016:11:27 03:02:03+00:00\nFile Access Date/Time           : 2016:11:27 03:06:03+00:00\nFile Inode Change Date/Time     : 2016:11:27 03:02:33+00:00\nFile Permissions                : rwxrwx---\nFile Type                       : PNG\nFile Type Extension             : png\nMIME Type                       : image/png\nImage Width                     : 320\nImage Height                    : 240\nBit Depth                       : 8\nColor Type                      : RGB\nCompression                     : Deflate/Inflate\nFilter                          : Adaptive\nInterlace                       : Noninterlaced\nXMP Toolkit                     : Image::ExifTool 9.74\nKeywords                        : ctf4b{f970e2767d0cfe75876ea857f92e319b}\nImage Size                      : 320x240\nMegapixels                      : 0.077\n```\n\n見えました！\n\n### ラクをする\n\nたぶん講義で紹介したWiresharkを使ってFlag探してね！って問題なんだろうなって思ったんですけど、\nstringsでゴリ押してしまいました＞＜\n\n```sh\nstrings for200 | grep ctf4b{\n```\n\n## ICMP？ (Forensics 200)\n\npcapファイルが渡されます。\n\nWiresharkで普通に開くと、pingのrequestとreplyだけが記録されています。\n眺めていると、1つだけサイズが大きい通信があります。（統計＞パケット長を見ても良かったかも。）\n\nで、このパケットを見ると、pingのDataに何故かHTTPレスポンスがのっています。\n\n```\nY'VERM]@@ {T HTTP/1.1 200 OK\nDate: Thu, 14 Jul 2016 14:28:30 GMT\nServer: Apache/2.4.20 (Debian)\nLast-Modified: Thu, 14 Jul 2016 14:21:21 GMT\nETag: \"35-537993754cce4\"\nAccept-Ranges: bytes\nContent-Length: 53\nContent-Type: text/plain\n\nY3RmNGJ7NTM2ZGFjMzcxYWE2NTJmODY1YzIwYWJlN2I0MDk0ZGJ9\nn\n```\n\nこの文字列、講義で習ったbase64っぽくないですか？\nということでデコードしてみます。\n\n```sh\n# echo Y3RmNGJ7NTM2ZGFjMzcxYWE2NTJmODY1YzIwYWJlN2I0MDk0ZGJ9 | base64 -d\nctf4b{536dac371aa652f865c20abe7b4094db}\n```\n\n### ラクをする\n\nまぁとりあえずstringsします！！！\n\n```sh\nstrings for200-2\n```\n\nそしたらbase64っぽい文字列が見えてしまったのでデコードしたらFLAGでした。\n（なんかbase64ってなんとなくわかりますよね）\n\n## adminでログインしろ！ (Forensics 300)\n\npcapとサービスのURLが渡されます。\n\nとりあえずSQLインジェクションとか試して見るんですけど、(まぁForensicsだし)ダメでした。\nで、よく見るとパスワードリセットができるようになっています。\nが、リセットしようとするとメールアドレスと郵便番号を入力しろと言われます。\n\nということで、サービス管理者の通信を盗聴したっぽいpcapを見に行きます。\nとりあえず脳死stringsしましたが成果がなかったので、Wiresharkを使って講義で習ったヤツをやってみました。\n\nWiresharkの統計＞プロトコル階層を見てみたところ、\nなんか大量の通信の中にちょっとだけSMTP(メール送信)の通信が記録されていました。\n（少ないやつは怪しいって講義で習いました。）\n\nで、この通信を覗いてみる(講義で習ったFollow TCP Stream)と、\nどうやら管理者と思しきアドレスから、画像つきで「引っ越しました！」みたいなメールを送っていました。\n\n```\n220 4a256f335dbb Python SMTP proxy version 0.2\nehlo debian.debian\n502 Error: command \"EHLO\" not implemented\nhelo debian.debian\n250 4a256f335dbb\nmail FROM:<admin@poe.ctf4b>\n250 Ok\nrcpt TO:<john@poe.ctf4b>\n250 Ok\ndata\n354 End data with <CR><LF>.<CR><LF>\nContent-Type: multipart/mixed; boundary=\"===============1980392290290904787==\"\nMIME-Version: 1.0\nTo: john@poe.ctf4b\nFrom: admin@poe.ctf4b\nSubject: 引越しました\n\n--===============1980392290290904787==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 8bit\n\n\n会津若松に引越しました.\nお近くにお越しの節はどうぞお気軽にお立ち寄り下さい.\n\n新居から見える景色を画像で添付します.\n\n\n--===============1980392290290904787==\nContent-Type: image/jpeg\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename=\"./keshiki.jpg\"\n\n<<<略>>>\n--===============1980392290290904787==--\n.\n250 Ok\nquit\n221 Bye\n```\n\nとりあえずこれで管理者のメールアドレス`admin@poe.ctf4b`は手に入ったので、次はメールに添付されている画像です。\n画像はbase64化されてメールにくっついているので、デコードしてみるんですが、見ても写っているのが何処かなんてピンと来ません。\n\nじゃあ、ということで講義で紹介されたexiftoolでEXIFを見ると……\n撮影した位置情報(GPS Position)がバッチリ残っていました。\n\n```sh\n# exiftool -GPSPosition keshiki.jpg\nGPS Position                    : 37 deg 29' 54.83\" N, 139 deg 56' 9.00\" E\n```\n\nこのGPS座標をGoogleMapとかに入れれば大体の場所がわかるので、あとは適当にググって郵便番号を割り出します。\nで、この2つの情報でパスワードリセットすればログインしてFlagが見れます。\n\n## Welcome Reversing World! (Reversing 100)\n\n実行すると`Enjoy CTF!`って出てきて終わります。\n\nバイナリがいきなりstrippedで読むのが辛い＞＜\n頑張って読むと、`Enjoy CTF!`を表示するちょっと手前に、なんか怪しいことをしてます。\n\n```x86asm\n 804841c:   c7 45 f0 00 00 00 00    mov    DWORD PTR [ebp-0x10],0x0\n 8048423:   c7 45 f4 e0 84 04 08    mov    DWORD PTR [ebp-0xc],0x80484e0\n 804842a:   83 7d f0 00             cmp    DWORD PTR [ebp-0x10],0x0\n 804842e:   74 10                   je     8048440 <__libc_start_main@plt+0x150>\n 8048430:   83 ec 0c                sub    esp,0xc\n 8048433:   ff 75 f4                push   DWORD PTR [ebp-0xc]\n 8048436:   e8 a5 fe ff ff          call   80482e0 <puts@plt>\n```\n\nC言語っぽく書けば\n```c\nint num = 0;\nchar* flag = 0x80484e0;\nif(num != 0){\n   puts(flag);\n}\n```\n\nみたいなカンジですね。\nまぁどう考えてもif文の中が実行されるワケがないですね。\nでもアドレスがわかるので、ココを見れば表示されるはずの文字列がわかります。\n\n`0x80484e0`は.rodataセクションの中なので、\n\n```sh\n# objdump -s -j.rodata bin100\n\nbin100:     file format elf32-i386\n\nContents of section .rodata:\n 80484d8 03000000 01000200 63746634 627b3537  ........ctf4b{57\n 80484e8 72316e36 355f6330 6d6d346e 645f6631  r1n65_c0mm4nd_f1\n 80484f8 6e645f66 6c34367d 00456e6a 6f792043  nd_fl46}.Enjoy C\n 8048508 54462100                             TF!.\n```\n\nありました。\n\n### ラクをする\n\n脳死stringsで見つかってしまった\n```sh\nstrings bin100\n```\n\n作問者さんによる解説でもstringsが想定解って言ってました(?)\n\n## Lecture Review (Reversing 200)\n\n与えられたバイナリの指定された部分(nopで囲まれたところ)を抜けると`%eax`の値はいくつになっているか？\n講義の演習でやった計算をやってみよう！ってやつですね。\n\nがんばって読んで計算するだけです。\n\n### ラクをする\n\ngdbを使うとちょっとラクできます。\n\n```sh\n# gdb -q ./bin200_1\nReading symbols from ./bin200_1...(no debugging symbols found)...done.\n(gdb) disas main\nDump of assembler code for function main:\n   0x08048416 <+0>:  push   ebp\n   0x08048417 <+1>:  mov    ebp,esp\n   0x08048419 <+3>:  sub    esp,0x10\n   0x0804841c <+6>:  nop\n   0x0804841d <+7>:  nop\n   0x0804841e <+8>:  mov    DWORD PTR [ebp-0xc],0x14\n   0x08048425 <+15>: mov    DWORD PTR [ebp-0x8],0x8\n   0x0804842c <+22>: mov    DWORD PTR [ebp-0x4],0xfffffffd\n   0x08048433 <+29>: push   DWORD PTR [ebp-0x4]\n   0x08048436 <+32>: push   DWORD PTR [ebp-0x8]\n   0x08048439 <+35>: push   DWORD PTR [ebp-0xc]\n   0x0804843c <+38>: call   0x80483db <calc>\n   0x08048441 <+43>: add    esp,0xc\n   0x08048444 <+46>: mov    ds:0x804a01c,eax\n   0x08048449 <+51>: mov    eax,ds:0x804a01c\n   0x0804844e <+56>: nop\n   0x0804844f <+57>: nop\n   0x08048450 <+58>: mov    eax,0x0\n   0x08048455 <+63>: leave\n   0x08048456 <+64>: ret\nEnd of assembler dump.\n(gdb) b*0x0804844e\nBreakpoint 1 at 0x804844e\n(gdb) r\nStarting program: /media/sf_share/bin200_1\n\nBreakpoint 1, 0x0804844e in main ()\n(gdb) i r\neax            0xffffffe5\t-27\necx            0xd4024da0\t-738046560\nedx            0xffffffe8\t-24\nebx            0x0\t0\nesp            0xffffdc18\t0xffffdc18\nebp            0xffffdc28\t0xffffdc28\nesi            0x1\t1\nedi            0xf7fc6000\t-134455296\neip            0x804844e\t0x804844e <main+56>\neflags         0x296\t[ PF AF SF IF ]\ncs             0x23\t35\nss             0x2b\t43\nds             0x2b\t43\nes             0x2b\t43\nfs             0x0\t0\ngs             0x63\t99\n```\n\n## Not Print FLAG (Reversing 200)\n\n渡されたバイナリを動かすと\n`Sorry. I forgot to display the FLAG. This message is not FLAG.`\nって言われて終わります。\n\n（strippedなのでつらいのですが＞＜）バイナリをよく読んでみると、\nなんだか怪しいことをしてる部分が見つかります。（↑を表示するちょっと手前の部分です）\n```x86asm\n 8048471:   c7 45 f0 00 00 00 00    mov    DWORD PTR [ebp-0x10],0x0\n 8048478:   eb 11                   jmp    804848b <putchar@plt+0x13b>\n 804847a:   8b 45 f0                mov    eax,DWORD PTR [ebp-0x10]\n 804847d:   8b 04 85 40 a0 04 08    mov    eax,DWORD PTR [eax*4+0x804a040]\n 8048484:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax\n 8048487:   83 45 f0 01             add    DWORD PTR [ebp-0x10],0x1\n 804848b:   8b 45 f0                mov    eax,DWORD PTR [ebp-0x10]\n 804848e:   83 f8 19                cmp    eax,0x19\n 8048491:   76 e7                   jbe    804847a <putchar@plt+0x12a>\n```\n\nどこかから何かを読んで`ebp-0xc`へ格納していますが、読み出した値は使ってませんね。\nあー！_forgot to display_ってそういうことか！\n\nで、読み出し元の`0x804a040`というのは.dataセクションなので、ココを見ると……\n```sh\n# objdump -s -j.data ./bin200_2\n\n./bin200_2:     file format elf32-i386\n\nContents of section .data:\n 804a020 00000000 00000000 00000000 00000000  ................\n 804a030 00000000 00000000 00000000 00000000  ................\n 804a040 31000000 6e000000 37000000 5f000000  1...n...7..._...\n 804a050 76000000 34000000 6c000000 75000000  v...4...l...u...\n 804a060 33000000 5f000000 33000000 71000000  3..._...3...q...\n 804a070 75000000 34000000 6c000000 5f000000  u...4...l..._...\n 804a080 63000000 68000000 34000000 72000000  c...h...4...r...\n 804a090 34000000 63000000 37000000 33000000  4...c...7...3...\n 804a0a0 72000000 00000000                    r.......\n```\n\nそれっぽいのが見つかりました。\n\n## Encrypted FLAG (Reversing 300)\n\nFLAGを入力するとそれが正解かどうかを判定してくれるバイナリです。\n\n.dataセクションになにやらそれっぽい`flag`っていう変数があります。\n\n```\n(gdb) x/s 0x804a02c\n0x804a02c <flag>:\t\"\\226\\201\\223\\301\\227\\216\\215\\232\\207\\252\\215\\232\\207\\252\\206\\234\\230\\205\\231\\220\\252\\226\\207\\214\\205\\201\\324\\324\\210\\365\"\n```\n\nどうやら暗号化されているようで、そのままでは読めないです。\n\nバイナリを読んでみると、`flag`を`decrypt`という関数で変換して、そのデータをstrcmpで入力と比較しています。\n\n実際にflagを変換している部分がココ\n```x86asm\n 8048558:   83 c4 10                add    esp,0x10\n 804855b:   83 ec 04                sub    esp,0x4\n 804855e:   6a 42                   push   0x42\n 8048560:   6a 1e                   push   0x1e\n 8048562:   68 2c a0 04 08          push   0x804a02c\n 8048567:   e8 73 00 00 00          call   80485df <decrypt>\n 804856c:   83 c4 10                add    esp,0x10\n 804856f:   83 ec 04                sub    esp,0x4\n 8048572:   6a b7                   push   0xffffffb7\n 8048574:   6a 1e                   push   0x1e\n 8048576:   68 2c a0 04 08          push   0x804a02c\n 804857b:   e8 5f 00 00 00          call   80485df <decrypt>\n```\n\n講義でやった関数呼び出しの話を思い出すと、\nどうやら`decrypt`に`flag`のアドレス、何らかの値①、何らかの値②を順番に渡しています。\n\n`0x804a02c`がflagのアドレスなので、C言語っぽく書いてみると、\n```c\ndecrypt(flag, 0x1e, 0x42);\ndecrypt(flag, 0x1e, 0xffffffb7);\n```\nこの0x1e、`strlen(flag) == 0x1e`なので、どうやらflagの長さっぽいですね。\n\nで、`decrypt`が何をしているかというと、\n\n```x86asm\n080485df <decrypt>:\n 80485df:   55                      push   ebp\n 80485e0:   89 e5                   mov    ebp,esp\n 80485e2:   83 ec 14                sub    esp,0x14\n 80485e5:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]\n 80485e8:   88 45 ec                mov    BYTE PTR [ebp-0x14],al\n 80485eb:   c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-0x4],0x0\n 80485f2:   eb 1c                   jmp    8048610 <decrypt+0x31>\n 80485f4:   8b 55 fc                mov    edx,DWORD PTR [ebp-0x4]\n 80485f7:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n 80485fa:   01 c2                   add    edx,eax\n 80485fc:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\n 80485ff:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n 8048602:   01 c8                   add    eax,ecx\n 8048604:   0f b6 00                movzx  eax,BYTE PTR [eax]\n 8048607:   32 45 ec                xor    al,BYTE PTR [ebp-0x14]\n 804860a:   88 02                   mov    BYTE PTR [edx],al\n 804860c:   83 45 fc 01             add    DWORD PTR [ebp-0x4],0x1\n 8048610:   8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]\n 8048613:   3b 45 0c                cmp    eax,DWORD PTR [ebp+0xc]\n 8048616:   7c dc                   jl     80485f4 <decrypt+0x15>\n 8048618:   90                      nop\n 8048619:   c9                      leave\n 804861a:   c3                      ret\n```\n\nこうなので、C言語っぽく書くとこうでしょうか？\n```c\nvoid decrypt(char* flag, int len, int num){\n\tfor(int i = 0; i < len; i++){\n\t\tflag[i] ^= num;\n\t}\n}\n```\n\nじゃあ、`flag`を実際に復号してみます。\n```c\n#include <stdio.h>\n\nchar flag[] = \"\\226\\201\\223\\301\\227\\216\\215\\232\\207\\252\\215\\232\\207\\252\\206\\234\\230\\205\\231\\220\\252\\226\\207\\214\\205\\201\\324\\324\\210\\365\";\n\nvoid decrypt(char* flag, int len, int num){\n   for(int i = 0; i < len; i++){\n      flag[i] ^= num;\n   }\n}\n\nint main(){\n   decrypt(flag, 0x1e, 0x42);\n   decrypt(flag, 0x1e, 0xffffffb7);\n   puts(flag);\n   return 0;\n}\n```\n\nイケました！\n\n### ラクをする\n\nstrcmpで比較するために、実行中にメモリにFLAGが乗っているはずなので、gdbで探してみます。\nstrcmpの直前でブレークして`flag`を見てみると、\n\n```sh\n# gdb -q ./bin300\nReading symbols from ./bin300...(no debugging symbols found)...done.\n(gdb) b*0x0804858f\nBreakpoint 1 at 0x804858f\n(gdb) x/s 0x0804a02c\n0x804a02c <flag>: \"ctf4b{xor_xor_simple_crypt!!}\"\n```\n\n### もっとラクをする\n\n`ltrace`っていう便利なモノがあります。\nコレを使うと、ライブラリ関数の呼び出しをトレースできます。\nつまり、strcmpに何を渡しているのかが見えます。\n\n```sh\n# ltrace ./bin300\n__libc_start_main(0x804851b, 1, 0xff932834, 0x8048620 <unfinished ...>\nprintf(\"Please input flag... \")                                      = 21\n__isoc99_scanf(0x80486b6, 0xff93273c, 0xff932740, 0x80482a9)         = 0xffffffff\nstrcmp(\"\\024\", \"ctf4b{xor_xor_simple_crypt!!}\")                      = -1\nputs(\"Wrong flag...\")                                                = 14\n+++ exited (status 0) +++\n```\n\n### おまけ\n\nangrを使ってみる\n\n```python\n# python2\n>>> import angr\n>>> p = angr.Project(\"./bin300\", load_options={\"auto_load_libs\":False})\n>>> state = p.factory.blank_state(addr=0x804851b)\n>>> path = p.factory.path(state)\n>>> pg = p.factory.path_group(path)\n>>> e = pg.explore(find=0x80485a7, avoid=0x80485b9)\n>>> e.found[0].state.posix.dumps(0)\n'ctf4b{xor_xor_simple_crypt!!}\\x00\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n```\n","title":"CTF for ビギナーズ 2016 金沢 に行った (writeup)","image":null,"tags":["CTF","CTF4b","参加記"],"date":"2016-11-27T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"}]},"__N_SSG":true}