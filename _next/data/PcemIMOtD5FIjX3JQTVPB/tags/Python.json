{"pageProps":{"tag":"Python","entries":[{"type":"article","slug":"18","body":"Win32APIでVOICEROIDをいじってみます\n\n\n# 東北きりたん\n\n[VOICEROID+ 東北きりたん EX](http://www.ah-soft.com/voiceroid/kiritan/)を買いました。\n\nhttp://www.ah-soft.com/voiceroid/kiritan/\n\n![](kiritan.png)\n\nう～～～～んかわいい！！！\nかわいいです。\n\n声もしっとりしていて完全にボク好みです。最高。\n\n# クラウドきりたん\n\nいろいろ使いみちが思いつくんですが、**Windowsでしか動かない**のがネックです……\n\nHTTPでテキストをぶん投げたら音声が飛んでくる感じになったら色々幸せじゃないですか。\nということで作っていきたいと思います。\n\n## Linuxで動かないかな？\n\nLinuxで動かすとすれば、Wineですね。\n\n[Linux の Docker の中で voiceroid+ ゆかりさんを動かす](http://pushl.net/blog/12/)という記事を見つけました。\nどうやらWineで動くみたい？しかもDockerの中で。すごい！\n\nhttp://pushl.net/blog/12/\n\n試してみたんですが、うまくいきませんでした＞＜\n**VOICEROID+ EX**になってからいろいろ変わったんでしょうか。\n\n自分でもWine環境を作って試してみたんですが、 .NET Framework 3.5のインストールがうまく行かず失敗。\n\nということでWineは諦めます。\n\n## WindowsServerで動かないかな？\n\n動作環境には当然乗っていませんが、Windows Server 2016で適当に試してみたら普通に動きました。\n\nですが、VOICEROIDにはGUIしかありません。\nCUIから操作できれば全て解決なんですが、用意されてません。かなしい。\n\nということで、Win32APIを叩いて自作プログラムからVOICEROIDの機能を使えるようにしてみましょう。\nとはいっても、GUIを無理やり操作して動かすだけです。\n筋肉ソリューション感が否めませんが、仕方がないです。\n\n# Win32APIを叩いてVOICEROIDを操作\n\nこのテの話は、「ウィンドウ 操作 Win32API」とかでググると無限に見つかるかと思うので、ザックリとだけ説明します。\n\n`SendMessage`関数を使うとユーザのマウス操作やキーボード操作がエミュレートできるので、\nうまい感じにテキストを入力させて保存ボタンを押させてあげれば、読み上げたwavファイルを得ることができそうです。\n\n## やりました\n\n方針が定まったら書くだけ……\nPythonで書いてみました。\n\nffmpegを使っているので、別途用意が必要です。\n必要なPythonのライブラリは`pypiwin32`です\n\n```sh\npip install pypiwin32\n```\n\n### コード\n\nhttps://github.com/kaz/kiritan-server/blob/aa4c4e4ed39bb024fb50f5392c8375dc4f4fa448/talk.py\n\n```python\n# coding: UTF-8\n\nimport os\nimport sys\nimport time\nimport hashlib\nimport threading\nimport subprocess\n\nfrom win32con import *\nfrom win32gui import *\nfrom win32process import *\n\n# 共通設定\nwaitSec = 0.5\nwindowName = \"VOICEROID＋ 東北きりたん EX\"\n\ndef talk(inputText):\n\t# 出力先ディレクトリ作成\n\toutdir = \"./output/\"\n\ttry:\n\t\tos.mkdir(outdir)\n\texcept:\n\t\tpass\n\n\t# ファイルが存在してたらやめる\n\toutfile = outdir + hashlib.md5(inputText.encode(\"utf-8\")).hexdigest() + \".mp3\"\n\tif os.path.exists(outfile):\n\t\treturn outfile\n\n\t# 一時ファイルが存在している間は待つ\n\ttmpfile = \"tmp.wav\"\n\twhile True:\n\t\tif os.path.exists(outfile):\n\t\t\ttime.sleep(waitSec)\n\t\telse:\n\t\t\tbreak\n\n\twhile True:\n\t\t# VOICEROIDプロセスを探す\n\t\twindow = FindWindow(None, windowName) or FindWindow(None, windowName + \"*\")\n\n\t\t# 見つからなかったらVOICEROIDを起動\n\t\tif window == 0:\n\t\t\tsubprocess.Popen([\"C:\\Program Files (x86)\\AHS\\VOICEROID+\\KiritanEX\\VOICEROID.exe\"])\n\t\t\ttime.sleep(3 * waitSec)\n\t\telse:\n\t\t\tbreak\n\n\twhile True:\n\t\t# ダイアログが出ていたら閉じる\n\t\terrorDialog = FindWindow(None, \"エラー\") or FindWindow(None, \"注意\") or FindWindow(None, \"音声ファイルの保存\")\n\t\tif errorDialog:\n\t\t\tSendMessage(errorDialog, WM_CLOSE, 0, 0)\n\t\t\ttime.sleep(waitSec)\n\t\telse:\n\t\t\tbreak\n\n\t# 最前列に持ってくる\n\tSetWindowPos(window, HWND_TOPMOST, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOMOVE | SWP_NOSIZE)\n\n\t# 保存ダイアログの操作\n\tdef enumDialogCallback(hwnd, param):\n\t\tclassName = GetClassName(hwnd)\n\t\twinText = GetWindowText(hwnd)\n\n\t\t# ファイル名を設定\n\t\tif className.count(\"Edit\"):\n\t\t\tSendMessage(hwnd, WM_SETTEXT, 0, tmpfile)\n\n\t\t# 保存する\n\t\tif winText.count(\"保存\"):\n\t\t\tSendMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, 0)\n\t\t\tSendMessage(hwnd, WM_LBUTTONUP, 0, 0)\n\n\t# 音声の保存\n\tdef save():\n\t\ttime.sleep(waitSec)\n\n\t\t# ダイアログがあれば操作する\n\t\tdialog = FindWindow(None, \"音声ファイルの保存\")\n\t\tif dialog:\n\t\t\tEnumChildWindows(dialog, enumDialogCallback, None)\n\t\t\treturn\n\n\t\t# 再試行\n\t\tsave()\n\n\t# VOICEROIDを操作\n\tdef enumCallback(hwnd, param):\n\t\tclassName = GetClassName(hwnd)\n\t\twinText = GetWindowText(hwnd)\n\n\t\t# テキストを入力する\n\t\tif className.count(\"RichEdit20W\"):\n\t\t\tSendMessage(hwnd, WM_SETTEXT, 0, inputText)\n\n\t\tif winText.count(\"音声保存\"):\n\t\t\t# 最小化解除\n\t\t\tShowWindow(window, SW_SHOWNORMAL)\n\n\t\t\t# 保存ダイアログ操作用スレッド起動\n\t\t\tthreading.Thread(target=save).start()\n\n\t\t\t# 保存ボタンを押す\n\t\t\tSendMessage(hwnd, WM_LBUTTONDOWN, MK_LBUTTON, 0)\n\t\t\tSendMessage(hwnd, WM_LBUTTONUP, 0, 0)\n\n\t# VOICEROIDにテキストを読ませる\n\tEnumChildWindows(window, enumCallback, None)\n\n\t# プログレスダイアログが表示されている間は待つ\n\twhile True:\n\t\tif FindWindow(None, \"音声保存\"):\n\t\t\ttime.sleep(waitSec)\n\t\telse:\n\t\t\tbreak\n\n\t# MP3に変換\n\tsubprocess.run([\"ffmpeg\", \"-i\", tmpfile, \"-acodec\", \"libmp3lame\", \"-ab\", \"128k\", \"-ac\", \"2\", \"-ar\", \"44100\", outfile])\n\n\t# 一時ファイルが存在していたら消す\n\ttry:\n\t\tos.remove(tmpfile)\n\t\tos.remove(tmpfile.replace(\"wav\", \"txt\"))\n\texcept:\n\t\tpass\n\n\treturn outfile\n\nprint(talk(sys.argv[1]))\n```\n\n## 注意\n\n一度適当なテキストを読み上げさせ、スクリプトを実行するディレクトリに保存させておく必要があります。\n保存先ダイアログを操作するときに、保存先ディレクトリを変更せずに保存させるため、\nスクリプトの実行ディレクトリと同じところがデフォルトになっていないと以後の処理が失敗します。\n\n手抜きです……\n\n## ハマりそうなポイント\n\n- ところどころにsleepを入れないと操作が失敗することがある\n- フォーカスが当たってないとか最小化されてるとかでボタン操作に失敗することがある\n- 出力が終わってない状況で新しい読み上げをさせようとすると死ぬ\n\t- 今回は前のが終わるまでブロックするようにした\n- Windowsのバージョンが違うと保存ウィンドウが違う気がするので上手く行かないかも\n\t- 今回はWindowsServer2016(Windows 10)です\n- 同じテキストの繰り返しを投げるとVOICEROIDがエラーを吐く\n\t- よくわからん\n\n# 次回予告\n\nということで、Pythonから好きなテキストをVOICEROIDに送って読み上げたWAVを得ることができるようになりました。\nコレだけでもうだいぶ夢が広がるカンジですね！！\n\n次回は、コイツをクラウドで動かしていつでもどこでもきりたんボイスが作れる環境を作ります。\n\n[クラウド東北きりたん その2 ～AzureのWindowsServerでVOICEROIDを動かす～](/posts/19/)\n","title":"クラウド東北きりたん その1 ～Win32APIでVOICEROIDを操作～","image":null,"tags":["VOICEROID","東北きりたん","Win32API","Python"],"date":"2017-05-25T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"}]},"__N_SSG":true}