{"pageProps":{"tag":"AppArmor","entries":[{"type":"article","slug":"28","body":"ISUCON10お疲れさまでした。運営の皆さん、ありがとうございました。\n\nボク、[@sekai67](https://twitter.com/sekai67)はNaruseJunチームの一員として出場しました。結果はこう。\n\n- 予選では、本選出場圏内の点数を取って余裕をカマしていましたが、追試をパスできずに予選落ち。\n- 本選では、[本選ライブ](http://isucon.net/archives/55063136.html)の企画で、並行チームとして問題に取り組ませてもらう。\n\t- 競技中最高得点 **52567** を記録するものの、追試をパスできず記録なし。伝統芸能\n\nこれは記念写真です。\n\n![](score.png)\n\nまあ追試で落ちてるんですけどね！\n\n参加記はチームメイトの[@to_hutohu](https://twitter.com/to_hutohu)と[@takashi_trap](https://twitter.com/takashi_trap)が書いてくれると信じて、ボクはちょっとしたこぼれ話を書いていきます。\n\n## やらかしリスト\n\n予選、本選どちらにおいても、思い返すとまあいろいろやらかしたんですが、今回は興味深かった2つを抜粋して掘り下げます。\n\n- 予選時、再起動試験を5回ぐらいして、追試落ちは絶対ない状態まで持っていったのに無事追試落ちした話\n- 本選開始後、初手でサーバの1台を使い物にならなくしてチームメイトを困惑させた話\n\n## 予選の追試で落ちた\n\n### 経緯\n\n予選では、チームメイトの2人がわりとギリギリまでアプリ実装のバグ取りを詰めていたので、ボクが1人で再起動試験や後片付けを担当することになりました。\n去年も再起動後に正しく動作させることができずに予選落ちしていますので、今年こそは！と念入りに何度も行っていました。\n\n5回ほど再起動してもOK、再起動後にもデータも正しく引き継がれている。絶対落ちないだろコレは！！！\nと自信満々で競技を終えたわけですが、結果発表でチーム名が呼ばれることはありませんでした……\n\n夜中、凹みつつも競技で使ったサーバの様子を見に行ってみると……\nDBサーバが落ちてるやんけ！！！！！なんで？？！？！？？！？？！！！\n\n### 理由\n\napparmorのポリシー(mysql-serverパッケージに入ってる`/etc/apparmor.d/usr.sbin.mysqld`)が生きていて、systemdがmariadbの起動を検知できておらず、`systemctl stop`相当の処理がかかったため。\n\nUbuntuで、最初にmysqlが動いている状態から、これをmariadbに置き換えると起動しなくなるという事例があります。\nこちらの記事が詳しいです。\n\n[Ubuntuでmysql-serverをmariadb-serverで置き換えるとsystemd経由でmariadbが起動できない](/posts/24/)\n\n## 疑問1: mariadbに入れ替えたときにto-hutohuが`aa-remove-unknown`でポリシーを消したのでは？\n\n先ほど紹介した記事を書いたのはボクです。ですので、もちろんこの挙動については知っていました。\n上記記事で紹介されている対策法をもちろん講じています。\n\nが、これはそもそも恒久対応ではありませんでした……！\nわかりにくい書き方でゴメンナサイ。\n\n先の記事で言及している、\n\n> /etc/apparmor.d/usr.sbin.mysqldは空のファイルで上書きされますが、AppArmorがすでに読み込んでいるプロファイルは削除されません。\n> また、systemctl reload apparmorしても、OSを再起動しても、一度読み込まれたプロファイルが勝手に削除されることはありません。\n\nここの理解が曖昧、あるいは間違っています。\n\nポリシーがOSを再起動しても消えない原因は、apparmorのポリシーキャッシュのせいで、`/etc/apparmor.d/cache/usr.sbin.mysqld`が存在して、かつ`/etc/apparmor.d/usr.sbin.mysqld`よりタイムスタンプが新しい場合、キャッシュのほうが読み込まれるという挙動をします。\n\n- `/etc/apparmor.d/cache/usr.sbin.mysqld`が作成されるのは、mysql-serverインストール時。\n\t- つまりタイムスタンプは → `Sep 11 11:34`\n- `/etc/apparmor.d/usr.sbin.mysqld`のタイムスタンプは、mariadbパッケージが作成された時。\n\t- つまりタイムスタンプは → `Jul 20 10:50`\n\nですので、`/etc/apparmor.d/usr.sbin.mysqld`が更新されたにも関わらず、キャッシュのほうがずっと読み込まれ続けてしまうのでした……！\n\n正しい対応は、`systemctl reload apparmor`でした。\nこれでキャッシュのflushが走り、正しくmariadbに起動するようになります。\n\n例の記事については、そのうち書き換えておきますね……\n\n### 疑問2: sekaiが再起動試験を行ったときにうまく動作していたのは何故？\n\n再起動後15分以内にのみ試験していたからです。\n\nAppArmorのせいでmariadbに起動に失敗するというのは、厳密に言うと、 **mariadbは起動に成功しているんだけどsystemdがそれを検知できていない** ということ。\nsystemdは一定時間（デフォルトで15分）以内にサービスの起動を確認できないと、ご丁寧にExecStopを走らせてくれるのです……！\n\nsekaiが再起動したのは **11:39:26 UTC** ごろ。\n\n```\n-- Reboot --\nSep 12 11:39:26 s2 systemd[1]: Starting MariaDB 10.1.44 database server...\nSep 12 11:39:32 s2 mysqld[1244]: 2020-09-12 11:39:32 139768179551360 [Note] /usr/sbin/mysqld (mysqld 10.1.44-MariaDB-0ubuntu0.18.04.1) starting as process 1244 ...\nSep 12 11:45:11 s2 systemd[1]: Stopped MariaDB 10.1.44 database server.\n-- Reboot --\n```\n\n11:45:11にStopしてるのは、このあともう一度再起動試験したためです。\n\nこの付近のkern.logは以下。\n\n```\nSep 12 11:39:35 s2 kernel: [   42.180656] audit: type=1400 audit(1599910775.956:18): apparmor=\"DENIED\" operation=\"sendmsg\" info=\"Failed name lookup - disconnected path\" error=-13 profile=\"/usr/sbin/mysqld\" name=\"run/systemd/notify\" pid=1244 comm=\"mysqld\" requested_mask=\"w\" denied_mask=\"w\" fsuid=111 ouid=0\n```\n\nsd-notify失敗してるので、この時点でもAppArmorのポリシーが生きています。\nsystemdはこのときずっとmariadbが上がってくるのを待っている状態です。\nただし、mariadb自体は起動しているので、アプリへのリクエストは通る状態です。\n（sekaiのこの状態でずっと再起動試験をしていたわけです。バカですねえ。）\n\n一方で、運営による再起動が行われたと思われる時刻(14:20:38 UTC つまり 23:20:38 JST)付近のログは以下のとおり。\n\n```\n-- Reboot --\nSep 12 14:20:38 s2 systemd[1]: Starting MariaDB 10.1.44 database server...\nSep 12 14:20:42 s2 mysqld[1100]: 2020-09-12 14:20:42 140238334753920 [Note] /usr/sbin/mysqld (mysqld 10.1.44-MariaDB-0ubuntu0.18.04.1) starting as process 1100 ...\nSep 12 14:35:41 s2 systemd[1]: mariadb.service: Start operation timed out. Terminating.\nSep 12 14:35:43 s2 systemd[1]: mariadb.service: Failed with result 'timeout'.\nSep 12 14:35:43 s2 systemd[1]: Failed to start MariaDB 10.1.44 database server.\n```\n\n15分立ったのでmariadbがshutdownされたと思われます。\n以下は`/var/lib/mysql/error.log`です。\n\n```\n2020-09-12 14:35:41 140238333712128 [Note] /usr/sbin/mysqld: Normal shutdown\n2020-09-12 14:35:41 140238333712128 [Note] Event Scheduler: Purging the queue. 0 events\n2020-09-12 14:35:41 140236692629248 [Note] InnoDB: FTS optimize thread exiting.\n2020-09-12 14:35:41 140238333712128 [Note] InnoDB: Starting shutdown...\n2020-09-12 14:35:41 140238333712128 [Note] InnoDB: Waiting for page_cleaner to finish flushing of buffer pool\n2020-09-12 14:35:43 140238333712128 [Note] InnoDB: Shutdown completed; log sequence number 3710056674\n2020-09-12 14:35:43 140238333712128 [Note] /usr/sbin/mysqld: Shutdown complete\n```\n\n実際にアプリにリクエストが来たのは、15:03:13 UTCでした。\n\n```\nSep 12 14:20:45 s1 isuumo[903]: ⇨ http server started on [::]:1323\nSep 12 15:03:13 s1 isuumo[903]: [mysql] 2020/09/12 15:03:13 packets.go:122: closing bad idle connection: unexpected read from socke\nSep 12 15:03:13 s1 isuumo[903]: [mysql] 2020/09/12 15:03:13 connection.go:158: driver: bad connection\nSep 12 15:03:13 s1 isuumo[903]: [mysql] 2020/09/12 15:03:13 packets.go:122: closing bad idle connection: unexpected read from socke\nSep 12 15:03:13 s1 isuumo[903]: [mysql] 2020/09/12 15:03:13 connection.go:158: driver: bad connection\n```\n\nこのとき、もうmariadbはshutdown済みなので、当然アプリは動かないわけですね……\n\n## 開始後即サーバを破壊\n\n### 経緯\n\n本選始まって直後の話。\n\nNaruseJunチームでは、Makefileをタスクランナー的に使っていて、[ここ](https://github.com/narusejun/isucon10-final/blob/master/Makefile)にデプロイコマンドを書いていました。\nsekaiがアプリにpprofを埋め込んだコードをプッシュし、サーバ上にデプロイしようとして`make deploy`を叩いたところ、なぜか途中で`sh: Command not found`のエラーが出てmakeが終了しました。\n\nアレ？`sh`って存在しないんだっけと思い、今度は`ls -l /usr/bin/sh`を実行してみると、今度は`bash: /usr/bin/ls: No such file or directory`が……\nここで全てを悟ります。これ、シェル組み込みのコマンド以外、全て使えなくなってるな……？\n\n心当たりがないわけではありませんでした。3人共、ある会話が頭をよぎりました……\nあれは予選時のことです――――\n\n> sekai「ミドルウェアの設定ファイルなども、リポジトリに含めてしまって、デプロイ時にrsyncで配置するようにしませんか？」\\\n> takashi「rsyncですか？どうやってやるんですか」\\\n> sekai「コマンド一発でできますよ。[こう](https://github.com/narusejun/isucon10-qualify/blob/master/Makefile#L50)ですね」\n\n```\n$ ls files\netc/       home/      lib/\n$ sudo rsync -r files/ /\n```\n\n> takashi「**これってもともとサーバ上にあるファイルが消えたりしませんか？**」←ここフラグ\\\n> sekai「大丈夫ですよ。ほら、追加したファイルだけ更新されてるでしょ？」\n\n予選では確かに、このコマンドでうまくデプロイできていました。\nですので、本選でも同じように設定ファイル類を配置しようとしていました。\n\nしかしながら、事実、サーバが壊れました。何故でしょう……\nこのときのログはこうでした。\n\n```\n〜〜〜略〜〜〜\nmake[1]: Leaving directory '/home/isucon/isucon10-final/app/webapp/golang'\nsudo rsync -v -r s1/ /\nsending incremental file list\ndeploy.sh\nskipping non-regular file \"etc/mysql/my.cnf\"\netc/envoy/config.yaml\netc/mysql/debian-start\netc/mysql/debian.cnf\netc/mysql/my.cnf.fallback\netc/mysql/mysql.cnf\netc/mysql/conf.d/mysql.cnf\netc/mysql/conf.d/mysqldump.cnf\netc/mysql/mysql.conf.d/mysql.cnf\netc/mysql/mysql.conf.d/mysqld.cnf\netc/systemd/system/envoy.service\netc/systemd/system/xsuportal-api-golang.service\netc/systemd/system/xsuportal-web-golang.service\nhome/isucon/env\nlib/\nlib/systemd/\nlib/systemd/system/\nlib/systemd/system/mysql.servicesent 11,952 bytes  received 375 bytes  24,654.00 bytes/sec\ntotal size is 10,449  speedup is 0.85\nsh s1/deploy.sh\nmake: sh: Command not found\nmake: *** [Makefile:54: start] Error 127\n```\n\nう〜ん、`--delete`オプションも付けてないし、このログを見ても特におかしくないしなあ。\n本選時はそう思っていました。\n\nここを詳しく調査する時間がもったいないので、運営にサーバをリセットしてもらい（ご迷惑おかけしました……）、とりあえず危険なMakefileは使用禁止として競技に戻りました。\n\n### その後\n\n競技は無事(?)終了し、翌日。ちゃんと調査しました。\n\nさて、件のログをよ〜く見ると、なんだかヤバそうなところが見つかりますね！？\n\n正解は`lib/`とだけ書いてある行です。\nこれは、rsyncによって`lib/`というディレクトリ、今回は宛先が`/`なので、要は`/lib`が作成されたという意味です。\nんん？？それはマズくないか？？？？？\n\nマズいです。コマンドがほぼ使えなくなったのは、間違いなく`/lib`にある共有ライブラリなどが消滅したからでしょう。\n\nでも、予選時はちゃんと動いていたんです。じゃあなんで？？？\n\n答えは、Ubuntuのバージョン違いにありました。\n予選では18.04、本選では20.04です。各バージョンでのルートディレクトリがどうなっているかと言うと……\n\n18.04では、こう。\n\n```\n# ls -l /\ntotal 64\ndrwxr-xr-x   2 root root 4096 Sep 21 17:17 bin\ndrwxr-xr-x   2 root root 4096 Apr 24  2018 boot\ndrwxr-xr-x   5 root root  360 Oct  4 07:46 dev\ndrwxr-xr-x   1 root root 4096 Oct  4 07:46 etc\ndrwxr-xr-x   2 root root 4096 Apr 24  2018 home\ndrwxr-xr-x   8 root root 4096 May 23  2017 lib\ndrwxr-xr-x   2 root root 4096 Sep 21 17:16 lib64\ndrwxr-xr-x   2 root root 4096 Sep 21 17:14 media\ndrwxr-xr-x   2 root root 4096 Sep 21 17:14 mnt\ndrwxr-xr-x   2 root root 4096 Sep 21 17:14 opt\ndr-xr-xr-x 174 root root    0 Oct  4 07:46 proc\ndrwx------   2 root root 4096 Sep 21 17:17 root\ndrwxr-xr-x   1 root root 4096 Sep 25 22:33 run\ndrwxr-xr-x   1 root root 4096 Sep 25 22:33 sbin\ndrwxr-xr-x   2 root root 4096 Sep 21 17:14 srv\ndr-xr-xr-x  13 root root    0 Oct  4 07:46 sys\ndrwxrwxrwt   2 root root 4096 Sep 21 17:17 tmp\ndrwxr-xr-x   1 root root 4096 Sep 21 17:14 usr\ndrwxr-xr-x   1 root root 4096 Sep 21 17:17 var\n```\n\n一方で20.04では……？\n\n```\n# ls -l /\ntotal 48\nlrwxrwxrwx   1 root root    7 Sep 25 01:20 bin -> usr/bin\ndrwxr-xr-x   2 root root 4096 Apr 15 11:09 boot\ndrwxr-xr-x   5 root root  360 Oct  4 07:46 dev\ndrwxr-xr-x   1 root root 4096 Oct  4 07:46 etc\ndrwxr-xr-x   2 root root 4096 Apr 15 11:09 home\nlrwxrwxrwx   1 root root    7 Sep 25 01:20 lib -> usr/lib\nlrwxrwxrwx   1 root root    9 Sep 25 01:20 lib32 -> usr/lib32\nlrwxrwxrwx   1 root root    9 Sep 25 01:20 lib64 -> usr/lib64\nlrwxrwxrwx   1 root root   10 Sep 25 01:20 libx32 -> usr/libx32\ndrwxr-xr-x   2 root root 4096 Sep 25 01:20 media\ndrwxr-xr-x   2 root root 4096 Sep 25 01:20 mnt\ndrwxr-xr-x   2 root root 4096 Sep 25 01:20 opt\ndr-xr-xr-x 171 root root    0 Oct  4 07:46 proc\ndrwx------   2 root root 4096 Sep 25 01:23 root\ndrwxr-xr-x   1 root root 4096 Sep 25 22:34 run\nlrwxrwxrwx   1 root root    8 Sep 25 01:20 sbin -> usr/sbin\ndrwxr-xr-x   2 root root 4096 Sep 25 01:20 srv\ndr-xr-xr-x  13 root root    0 Oct  4 07:46 sys\ndrwxrwxrwt   2 root root 4096 Sep 25 01:23 tmp\ndrwxr-xr-x   1 root root 4096 Sep 25 01:20 usr\ndrwxr-xr-x   1 root root 4096 Sep 25 01:23 var\n```\n\nアッ……（完全に理解）\n\nUbuntu 20.04では、`/lib`は通常のディレクトリではなく、`/usr/lib`へのシンボリックリンクでした！\nrsyncでは、デフォルトではシンボリックリンクの先がディレクトリであっても、それを辿ってその先にコピーをしたりしません。\nソース側のディレクトリでそのまま上書きして、もとのリンクは消してしまうんですね……！\n\n### 教訓\n\nこの悲劇を回避するには、rsyncの`--keep-dirlinks`というオプションを使うべきでした。\n以下、`man rsync`より引用です。\n\n> -K, --keep-dirlinks\n>     This option causes the receiving side to treat a symlink to a directory as though it were a real directory, but only if it matches a real directory from the sender. Without this option, the receiver's symlink would be deleted and replaced with a real directory.\n>     For example, suppose you transfer a directory lqfoorq that contains a file lqfilerq, but lqfoorq is a symlink to directory lqbarrq on the receiver. Without --keep-dirlinks, the receiver deletes symlink lqfoorq, recreates it as a directory, and receives the file into the new directory. With --keep-dirlinks, the receiver keeps the symlink and lqfilerq ends up in lqbarrq.\n\nちょうどボクが踏んだ罠について言及されています。\nrsyncは気をつけて使います……\n\n## おしまい\n\nISUCONは学びが多い。\n\nあと、予選で雑にmysqlの全テーブルをMEMORYストレージエンジンにしたらメモリが完売してSSHできなくなって焦るなどの事件もありました。\n（運営に再起動してもらって事なきを得ました。）\n","title":"ISUCON10 やらかしリスト","image":null,"tags":["AppArmor","ISUCON","systemd","インフラ","参加記"],"date":"2020-10-04T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"}]},"__N_SSG":true}