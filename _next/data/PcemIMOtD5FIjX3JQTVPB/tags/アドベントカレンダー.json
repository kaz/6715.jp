{"pageProps":{"tag":"アドベントカレンダー","entries":[{"type":"article","slug":"29","body":"おうちネット、最近は楽天ひかりを契約してます。\n楽天モバイルとセットで申し込むと、ひかりも通信料1年間無料になって激アツです。\n\n[IQ1 Advent Calendar 2020](https://adventar.org/calendars/5197) - 16日目の記事です。\n\n[IQ1 Advent Calendar 2020](https://adventar.org/calendars/5197)\n\n## 自宅サーバ\n\n世はまさに大クラウド時代！\n**自宅サーバ**とかいう文字列を目にすることも、こころなしか少なくなったような気がします。\n\n普通の家庭向けインターネット接続サービスではIPv4アドレスが1つしか割当されないのに対して、宅内にはたくさんの端末がある……ので、NAPTでうまいことさばいているのが普通かと思います。\nこういう環境下で家にサーバを置くには、いわゆるポート開放[^1]、静的NAPTの設定が必要になるわけですね。\n\n[^1]: この言い方は好きじゃないですが、よく使われているのでコレで……\n\n## IPv4 over IPv6での自宅サーバ公開\n\n楽天ひかりはIPv4 over IPv6に対応しています。\nこのやりかたでIPv4ネットワークに接続すると、旧来のPPPoEによる接続と比較してパフォーマンスが良い、とされています。\n\nIPv4 over IPv6の実現する方式にはいくつか種類があって、楽天ひかりはXpass（クロスパス）と呼ばれる方式を利用しているとのこと。なんだかカッコいい名前がついていますが、一般的にはDS-Liteと呼ばれるやつですね。\n\nが、DS-Lite方式のIPv4 over IPv6では、いわゆるポート開放ができません。残念。\nでは自宅サーバは公開できないのか？というとそうでもなくて、依然として旧来のPPPoE接続はできるので、こっちを通るようにすれば良いです。\n\n## DS-LiteとPPPoEの併用\n\n家庭用のルータだとそもそもコレができる機種は限られています。\nここは課金ポイントです。業務用っぽいやつを買いましょう。\n\nボクはYAMAHAのNVR510を買いました。\n具体的な設定手順は省きますが、DS-LiteとPPPoEの両方でIPv4ネットワークに接続できたとしましょう。\n\n![](1.png)\n\n当然ですが、DS-Lite側とPPPoE側で別々のアドレス`X.X.X.X`と`Y.Y.Y.Y`を持っているような状態になっています。\n\n普段の通信は、パフォーマンスが良いとされているDS-Lite側(`tunnel 1`)を通したいです。\nなので、デフォルトゲートウェイはこっち側にします。\n\n```\nip route default gateway tunnel 1\n```\n\nこういう感じになっています。\n\n![](2.png)\n\n## 自宅サーバ宛の通信をPPPoE側で受け入れる\n\n今回はHTTPサーバを公開するということにして、PPPoE側のアドレスに来た`80/tcp`の通信をサーバが受け取れるように、静的NAPT[^2]エントリを追加します。\n\n[^2]: YAMAHA製品ではIPマスカレードという名称\n\n```\nnat descriptor type 1 masquerade\nnat descriptor masquerade static 1 100080 192.168.0.250 tcp www\npp select 1\n  ip pp nat descriptor 1\n```\n\nこれで、外の端末からの通信がサーバに到達できるようになりました。\nTCPだと、まず`SYN`パケットが送られてきますよね。\n\n![](3.png)\n\nで、サーバは`SYN/ACK`で応答するわけです。3-wayハンドシェイクというやつの2番目です。\nクライアント(`Z.Z.Z.Z`)がどこにいるなんて末端のサーバは知りません。なので、とりあえず家庭内のルータに丸投げします。当の家庭内ルータもその上位ルータへ投げるだけです。このとき、**デフォルトゲートウェイをDS-Lite側に設定**しているので、当然この`SYN/ACK`もそっち側に行ってしまいます。\n\n![](4.png)\n\nすると、クライアントからするとおかしな事が起こっているように見えるわけです。`Y.Y.Y.Y`に送った`SYN`の返答がなぜか`X.X.X.X`から帰ってくる……これではTCP接続は確立できません。\n返りの通信もPPPoEを通るようにしないとダメそう。\n\nちなみに、UDPならこの状態でも通信できる可能性があります。\n\n## 返りの通信もPPPoEを通す\n\nポリシーベースルーティング（PBR）[^3]をします。\nある条件に合致するような通信だけ、別の経路に流したりできる機能です。\nこれも業務用クラスのルーターじゃないと使えない場合が多そうです。\n\n[^3]: YAMAHA製品ではフィルタ型ルーティングに相当\n\n今回は、HTTPサーバを公開したいという状況なので、送信元が件の自宅サーバでかつポート番号が`80`のときだけ、PPPoE側(`pp 1`)にルーティングするようにします。\n\n```\nip filter 100080 pass 192.168.0.250 * tcp www *\nip route default gateway pp 1 filter 100080 gateway tunnel 1\n```\n\nこれで、こうなります。`SYN`のdstと`SYN/ACK`のsrcが一致して、クライアントは`ACK`を返してくれることでしょう……晴れて接続確立です。\n\n![](5.png)\n\n## おしまい\n\nおわりです。\nなんかもっといい方法ないのかな。\n\n### おまけ：パケットキャプチャ\n\nサーバ側はこう。`192.168.0.250`が宅内のサーバで、`133.130.113.115`は外にいるクライアント。\n`SYN/ACK`をめちゃ再送している。\nクライアントが再送した`SYN`もいっぱい来てる。\n\n![](server.png)\n\nクライアント側。\n`SYN`を再送してる。サーバが送った`SYN/ACK`はそもそも届いてない。\n途中の誰かが捨ててるのかな……（ここわからん）\n\n![](client.png)\n","title":"DS-Lite/PPPoE併用環境で自宅サーバの通信だけPPPoEを通す","image":null,"tags":["DS-Lite","PPPoE","アドベントカレンダー","インフラ","ネットワーク"],"date":"2020-12-16T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"external","url":"https://qiita.com/sekai/items/b5e5e05da2dfe6ff1bf3","publisher":"Qiita","title":"Name Service SwitchでConoHaインスタンスのIPアドレスを引く","tags":["Qiita","アドベントカレンダー","ConoHa","NSS","インフラ"],"date":"2019-12-19T22:00:46.000Z"},{"type":"article","slug":"26","body":"この記事は[CTF Advent Calendar 2018](https://adventar.org/calendars/3210)の23日目の記事です！\n\n[CTF Advent Calendar 2018](https://adventar.org/calendars/3210)\n\n本稿では、Ethereumスマートコントラクトを用いて、CTF（に限らず、様々なイベント）の賞金支払いをどう行うか？を検討してみます。\n\n## はじめに\n\n[**Capture The Flag**](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%97%E3%83%81%E3%83%A3%E3%83%BC%E3%83%BB%E3%82%B6%E3%83%BB%E3%83%95%E3%83%A9%E3%83%83%E3%82%B0#%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3)においては、その上位者に賞金が支払われる大会がしばしば開催されている。\n\nこうしたCTFをはじめとする各種賞金付き大会において、その賞金の支払いを**DApps**を用いて行う事を考える。\n\n## DAppsを用いる意義\n\n- 確かに賞金が用意されていることを証明できる\n- 主催者が賞金を支払う意志があることをアピールできる\n- 入賞者自身が引き出しを行うので、支払いの手間がかからない\n\n# DAppsを用いた賞金付きCTF\n\n今回は簡単化のため、**優勝者のみに賞金が支払われ**、**問題数は1つ**（正解のFLAGが1つ）の単純な大会を想定とする。\nまた、優勝者は「FLAGを入手し、賞金支払い手続きを最も早く行った参加者」と定義する。\n\nDAppsやブロックチェーンなど、分散基盤上で「賞金支払い」を行う場合に、大きく問題となるのが**未受理トランザクション**の存在である。\n要は、未受理のままネットワーク（mempool）を漂っているトランザクションをコピーしてより高い手数料を付与すれば、最初にトランザクションを投入した参加者の賞金受け取り権利を横取りできてしまう、という話である。\n\n優勝者が**必ず、もしくは極めて高い確率で賞金を手にする**ことができるDAppsを考えてみよう。\n\n## 従来手法\n\n### [1]: [Bitcoinによる新しいCapture The Flag（CTF）](https://qiita.com/yyu/items/b6f367eb876dd28e759a)\n\n[Bitcoinによる新しいCapture The Flag（CTF）](https://qiita.com/yyu/items/b6f367eb876dd28e759a)\n\nこの手法では、FLAG検証に参加者固有の値を用いることで先述の問題を解決している。\nブロックチェーン上に**各参加者ごとに固有のFLAGハッシュ**を予め記憶しておくことで、検証を行う。\n\nチーム$T_i$はFLAG文字列$F$を入手すると、$h_i=H(F||i)$を含むトランザクションを提出する。$H$は適当なハッシュ関数である。\nこのトランザクションに対し、予め記録されている$ans_i=H(h_i)$と比較することで正しいFLAGを持っているか検証できる。\n仮にチーム$T_j$がこのトランザクションをコピーしても、チーム$T_j$に対する正解$ans_j$は$ans_i$と異なるため、正解とみなされない。\nまた、$h_i$を入手してもハッシュの原像計算困難性により、$F$は入手できない。\n\nEthereumを用いて実装した例もある。\n\n[Solidityで作るCapture The Flag](http://lotz84.hatenablog.com/entry/2018/01/02/134056)\n\nしかし、[1]では**予めCTFイベントへの参加者が確定している**必要があり、開始時刻以降は参加者を追加できない。\n開催中にイベントの存在を知ったユーザが新たに参加できず、ユーザビリティを欠いている。\n\n### [2]: [ERC20トークンを用いた宝探しゲーム(真)の提案](https://trap.jp/post/561/)\n\n[ERC20トークンを用いた宝探しゲーム(真)の提案](https://trap.jp/post/561/)\n\nこの手法では、テーマとして「宝探し」を取り扱っているが、秘密の文字列を何らかの手段によって入手した参加者に報奨を与えるという点で、\n**お宝**を**FLAG**に、**ERC20トークン**を**賞金**と読み替えれば、CTFにおける賞金支払いに応用可能である。\n\n基本的なアイデアは[1]とほぼ同等で、**各参加者ごとに固有のFLAGハッシュ**がスマートコントラクト上に記録されている。\n\n[1]と異なるの　は、後から参加者の追加を可能としている点である。\n[1]がBitcoinの`scriptPubKey`で記述されているのに対して、[2]ではEthereumスマートコントラクト上で実装しているため、より柔軟なDAppsが記述できている。\n\nしかしながら、[2]では参加者の追加をするために**主催者が手数料を支払う必要がある**。\n一度デプロイが完了した後にも、コントラクトの面倒を見続ける必要があるのは欠点であると言えよう。\n\n加えて、DoS攻撃の余地がある。\nEthereumのEOAアドレスは無コストで生成可能であるので、何度も参加要求を送り続けければ、主催者のEthereumが枯渇してしまう。\nこれを防ぐには、何らかのオフチェーン要素とアドレスを紐付けて個人を特定する、CTFへの参加に手数料を徴収する、などが考えられる。\nしかし、これらは主催者側の負担が大きい。到底De-centralized Appsとは呼べるものではない！\n\nさらに、[2]では**主催者がこっそり賞金を自分の懐に収める**可能性を排除できない。\n[1]では、予め参加者を確定させておくことでこの問題をうまく回避している。\n\n## 提案手法\n\n提案手法では、**後から参加者が追加可能であり、その際に手数料を必要としない**ことを目標とする。\nまた、DAppsプラットフォームとしては、Ethereumスマートコントラクトを想定している。\n\n## [N案]: コミットメントによる引き出し\n\n本手法では、予めFLAGハッシュをコントラクト上に乗せることなく、検証時には参加者ごとに異なるFLAGハッシュを用いて検証することを目指す。\nこれを可能とするのが**コミットメント方式**である。コミットメントについては、[Wikipediaの解説](https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%83%A1%E3%83%B3%E3%83%88)や[ブロックチェーンを利用した公平なガチャの提案](https://qiita.com/yyu/items/4eaa43693e39c60a8661)が詳しい。\n\nコントラクト上には、FLAG文字列$F$のハッシュ$F'=H(F)$を予め記録されている。$H$は適当なハッシュ関数である。\nまず、**commit**と**reveal**の2つの操作を定義する。\n\n**commit**は、言わば**賞金を引き出す権利の予約**である。\n参加者$T_i$は、FLAG文字列$F$を入手すると、自身のアドレス$A_i$を用いてコミット$C_i=H(F||A_i)$を送信する。\nコミット$C_i$は、コントラクト上に格納される。また、$C_i$は従来手法で予めコントラクト上に格納しておくものと等しい。\nこの時点では、トランザクションを観察しても$F$は復元困難である。これがコミットメント方式の**秘匿性**である。\n\n**reveal**は、**予約した権利が正当であることを証明**し、それを行使して**賞金を引き出す**操作である。\n参加者$T_i$は、FLAG文字列$F$を単に公開する。コントラクトは、$H(F)$を計算し、予め記録されている$F'$と比較して、FLAG文字列が正しいかを確認した後、\n$H(F||A_i)$を計算し、commit時に記録された$C_i$と比較を行うことで、**参加者はcommitの時点でこのFLAGを本当に所有していたのかを確認する**。\n以上で、commit時点で正しいことFLAGを所有していたことが確認されれば、直ちに賞金を支払う。\ncommit時に提出したFLAGは、reveal時に変更できない。これがコミットメント方式の**拘束性**である。\n\nコミットメント方式による賞金支払いでは、**revealした瞬間にFLAG文字列が全員に対して明らかになる**点に注意が必要である。\nそのため、検証を2段階に分けたとしても、誰かがrevealした瞬間に高手数料でcommitし、すぐにrevealすれば逆転可能性がある。\n\nこの手法のキモは、**commitから一定時間（ブロック高）が経過しないとrevealできない**ような制約を設けることにある。\nこれによって、revealトランザクションを投入した瞬間から一定時間内は、**攻撃者は絶対に引き出しができない**。\nしたがって、この一定時間内にrevealトランザクションが承認されれば良いため、極めて高い確率で**最も先にcommitした参加者に**賞金が支払われる。\n一定時間の遅延は、言わば攻撃者の賞金引き出し操作を遅延させるために存在するものと言える。\n\nSolidityによる実装例は以下。\n\n```js\npragma solidity ^0.5.0;\n\ncontract Prize {\n\tevent Commit(address sender, uint revealable);\n\n\tbytes32 private flagHash;\n\n\tmapping(address => bytes32) private commits;\n\tmapping(address => uint) private revealable;\n\n\tconstructor(bytes32 _flagHash) public payable {\n\t\tflagHash = _flagHash;\n\t}\n\n\tfunction commit(bytes32 commitment) external {\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, revealable[msg.sender] = block.number + 128);\n\t}\n\tfunction reveal(bytes32 flag) external {\n\t\trequire(calcFlagHash(flag) == flagHash);\n\t\trequire(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\trequire(block.number >= revealable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction calcFlagHash(bytes32 flag) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag));\n\t}\n\tfunction calcCommitment(bytes32 flag, address sender) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n```\n\n## [A案]: コミットメントによる権利移転\n\n[N案]では、要件を満たす賞金支払いDAppsを定義したが、この方式には1点課題が残る。\nそれは、**一定時間が経過しなくてもrevealできてしまう**点である。\n\nこの場合、正しく実装されたコントラクトでは、支払いは行われず、**FLAGが想定より早く公開されてしまう**。\n一定時間が経過する前にrevealした参加者は、我々が苦心して用意した権利保護期間を自ら捨て去ってしまったことになるのだ！\n\n[N案]を拡張し、こうした誤操作が起こりえない、言わばフールプルーフ的な構造を取り入れたのが[A案]である。\n\n**commit**と**reveal**の2つに加えて、新たに**withdraw**操作を定義する。\n\n**commit**では、[N案]の$C_i$に加えて、commitした時刻（ブロック高）を記録しておく。\n\n**reveal**では、[N案]と同様の検証を行った後に、**権利の移転**を行う。\n[A案]では、コントラクト上で「現在の引き出し権利者」（優勝者）を記憶している。\n権利の移転とは、現在の権利者がcommitした時刻よりも、早い時刻にcommitした参加者がrevealした際に、権利を移動する操作である。\n\nそして**withdraw**は、引き出し権利を行使して賞金を引き出すものである。\nこの権利行使を遅延させるのが[A案]である。遅延は、「commit時から一定時間後」でもいいし「権利取得時から一定時間後」でも良い。\ncommit時から一定時間後としたほうが、参加者の待ち時間は短くなり、ユーザビリティが向上するだろう。\n\nこれによって、commit後に即時revealしても損をすることがない。\nrevealトランザクションを見てすぐさま権利を横取りしたとしても、withdrawの遅延によってすぐに引き出せないし、その間に正当権利者がrevealすれば良い。（commitが最も早いものが最終的な権利を得る。）\n\nSolidityによる実装例は以下。\n\n```js\npragma solidity ^0.5.0;\n\ncontract Prize {\n\tevent Commit(address sender, uint withdrawable);\n\tevent Reveal(address sender, uint withdrawable);\n\n\tbytes32 private flagHash;\n\taddress payable private winner;\n\n\tmapping(address => bytes32) private commits;\n\tmapping(address => uint) private withdrawable;\n\n\tconstructor(bytes32 _flagHash) public payable {\n\t\tflagHash = _flagHash;\n\t}\n\n\tfunction commit(bytes32 commitment) external {\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, withdrawable[msg.sender] = block.number + 128);\n\t}\n\tfunction reveal(bytes32 flag) external {\n\t\trequire(calcFlagHash(flag) == flagHash);\n\t\trequire(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\trequire(winner == 0 || withdrawable[msg.sender] < withdrawable[winner]);\n\t\temit Reveal(winner = msg.sender, withdrawable[msg.sender]);\n\t}\n\tfunction withdraw() external {\n\t\trequire(msg.sender == winner);\n\t\trequire(block.number >= withdrawable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction calcFlagHash(bytes32 flag) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag));\n\t}\n\tfunction calcCommitment(bytes32 flag, address sender) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n```\n\n## 提案手法の課題\n\n### 主催者による賞金回収\n\n[2]の問題として上げた以下の点は、解決できていない。\n\n> **主催者がこっそり賞金を自分の懐に収める**可能性を排除できない。\n\nしかし、後から参加者の追加を許す場合では、この可能性を排除することは極めて難しい。\nこの問題についてはとりあえずは目をつむって、主催者は信頼に足る人間である、ということにしておこう……！\n\n### 暗号通貨に価値があることを前提としている\n\nまぁいいじゃん。\nアゼルバイジャン。\n\n## おわりに\n\nコミットメントの持つ秘匿性・束縛性を活用し、後から参加者が追加可能であり、その際に手数料を必要としない賞金支払いコントラクトを提案した。\n\n### 謝辞\n\n本稿は、[@42_0N](https://twitter.com/42_0N)氏との長時間に渡る議論を経て書き上げたものです。\nありがとナス！！！！！！！！\n\n----\n\nところで、最近公開したミニCTF:[NaruseJunCTF](https://we.are.participating.in.seccon.international/)はプレイして頂けましたか？\nなんと、全問正解者には賞金があります！（2018/12/23 現在 まだ賞金は残ってます）\n賞金支払いには[N案]コントラクトを用いていますヨ。DAppsによる賞金受け取りを是非体験してみてくださいネ。\n","title":"DAppsによる賞金付きCTF","image":null,"tags":["CTF","DApps","Ethereum","アドベントカレンダー","スマートコントラクト"],"date":"2018-12-23T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"article","slug":"25","body":"この記事は[ConoHa Advent Calendar 2018](https://qiita.com/advent-calendar/2018/conoha)の21日目の記事です！\n\n[ConoHa Advent Calendar 2018](https://qiita.com/advent-calendar/2018/conoha)\n\n# ConoHaの[DNS API](https://www.conoha.jp/docs/)は便利\n\nという話を[2年前](/posts/14/)にもしたのでした。\n\n[2年前の記事](/posts/14/)\n\n皆さん、ConoHaのDNS API使ってますか？\nLet's EncryptのDNS-01チャレンジの自動化にも使える！のでイケてますね。\n\n## APIクライアントについて\n\nさて、ではどうやってAPIを叩くか？\n先に紹介した記事の要旨は「ConoHa DNS用 APIクライアント 作った」なんですが、あまりにも使い辛いので無視します。\n\n### Designateクライントを使う\n\nConoHaのDNSは[OpenStack Designate](https://docs.openstack.org/designate/latest/)を使っているようです。多分。API体系がソレっぽいので。\n\nなので、[Designateのクライアント](https://docs.openstack.org/python-designateclient/latest/cli/index.html)が使えるかもしれない……？（未確認）\n\nしかし、ConoHaではdeprecatedなv1 APIのみ提供されているので、互換性の面で死ぬかもしれません。\n[一応v2も動いている](https://dns-service.tyo1.conoha.io/)ようですが、不完全なようですし、そもそもundocumentedです。\n\n### Lexiconを使う\n\n様々なDNSサービスを1つのCLIから使えるようにしたソフトウェアが[Lexicon](https://github.com/AnalogJ/lexicon)です。\n\nなんと**ConoHa DNSに対応**しています！すごい！！\n（まぁ、ボクが使うために対応させたからなんですケド……）\n\n便利なので使ってください。pipさえあればGetできます。\nこんな具合に使えるかと思います。\n\n```\n$ pip install dns-lexicon\n\n$ lexicon conoha\nusage: lexicon conoha [-h] [--name NAME] [--content CONTENT] [--ttl TTL]\n                      [--priority PRIORITY] [--identifier IDENTIFIER]\n                      [--log_level {CRITICAL,ERROR,WARNING,INFO,DEBUG,NOTSET}]\n                      [--output {TABLE,TABLE-NO-HEADER,JSON,QUIET}]\n                      [--auth-region AUTH_REGION] [--auth-token AUTH_TOKEN]\n                      [--auth-username AUTH_USERNAME]\n                      [--auth-password AUTH_PASSWORD]\n                      [--auth-tenant-id AUTH_TENANT_ID]\n                      {create,list,update,delete} domain\n                      {A,AAAA,CNAME,MX,NS,SOA,TXT,SRV,LOC}\n\n$ lexicon conoha --auth-region tyo1 --auth-username gncu01234567 --auth-password xxxxxxxxxxx --auth-tenant-id 0123456789abcdef0123456789abcdef create narusejun.com A --name local --content 127.0.0.1\n$ lexicon conoha --auth-region tyo1 --auth-username gncu01234567 --auth-password xxxxxxxxxxx --auth-tenant-id 0123456789abcdef0123456789abcdef list narusejun.com A\nID                                   TYPE NAME                CONTENT   TTL\n------------------------------------ ---- ------------------- --------- ----\n42929801-5111-41d5-a115-9f67a1d07810 A    local.narusejun.com 127.0.0.1 3600\n```\n\n詳しくは[公式のドキュメント](https://github.com/AnalogJ/lexicon)を読んでください。\nLet's EncryptのDNS-01を自動化するやり方も紹介されていますよ！\n\n## Let's EncryptのDNS-01チャレンジを自動化する\n\nせっかくAPIでDNSレコードを操作できるわけですし、活用したいですね！\n\n最近[ワイルドカード証明書が取れるようになった](/posts/23/)Let's Encryptと連携してみましょう。\nちなみに、ワイルドカード証明書はDNS-01チャレンジでしか取得できません！\n\n### LexiconとDehydratedを使う\n\n先ほど紹介したlexiconと、ACMEクライアント[Dehydrated](https://github.com/lukas2511/dehydrated)を組み合わせるやり方がlexiconの作者さんによって紹介されています。\n\nhttps://blog.thesparktree.com/generating-intranet-and-private-network-ssl\n\n### Legoを使う\n\n2つのソフトウェアを連携させるのは面倒ですし、できればパパッとコマンド1つで証明書取りたいですよね？\nそこで、Go製のACMEクライアント[lego](https://github.com/xenolf/lego)を使いましょう！\nlegoでは、いろんなDNS-Providersが提供されていて、対応しているDNSサービスならすぐに証明書を発行できます。\n\n[lego](https://github.com/xenolf/lego)\n\nなんと**ConoHa DNSに対応**しています！すごい！！\n（まぁ、ボクが使うために対応させたからなんですケド……）\n\n[バイナリが入手可能](https://github.com/xenolf/lego/releases)なほか、goがインストールされているなら`go get`ですぐに入手できます。\nこういう感じで使います。とっても便利ですよ！\n\n```\n$ go get -u github.com/xenolf/lego/cmd/lego\n\n$ lego dnshelp\nCredentials for DNS providers must be passed through environment variables.\n\nValid providers and their associated credential environment variables:\n        conoha:         CONOHA_REGION, CONOHA_TENANT_ID, CONOHA_API_USERNAME, CONOHA_API_PASSWORD\n\nAdditional configuration environment variables:\n        conoha:         CONOHA_POLLING_INTERVAL, CONOHA_PROPAGATION_TIMEOUT, CONOHA_TTL, CONOHA_HTTP_TIMEOUT\n\n$ export CONOHA_REGION=tyo1\n$ export CONOHA_TENANT_ID=0123456789abcdef0123456789abcdef\n$ export CONOHA_API_USERNAME=gncu01234567\n$ export CONOHA_API_PASSWORD=xxxxxxxxxxx\n$ lego --dns conoha --server https://acme-staging-v02.api.letsencrypt.org/directory --email cert@narusejun.com --domains narusejun.com --domains *.narusejun.com run\n2018/12/21 02:44:58 [INFO] [narusejun.com, *.narusejun.com] acme: Obtaining bundled SAN certificate\n2018/12/21 02:44:59 [INFO] [*.narusejun.com] AuthURL: https://acme-staging-v02.api.letsencrypt.org/acme/authz/wcYZJB5aWmfi4WzGuwv2JlSaYjryGf67zqES8h8bmEg\n2018/12/21 02:44:59 [INFO] [narusejun.com] AuthURL: https://acme-staging-v02.api.letsencrypt.org/acme/authz/gwXBvxvuHk7TrUYbuu3MWp7heVoLTTle7Nh2ng98b74\n2018/12/21 02:44:59 [INFO] [narusejun.com] acme: Authorization already valid; skipping challenge\n2018/12/21 02:44:59 [INFO] [narusejun.com] acme: Preparing to solve DNS-01\n2018/12/21 02:45:00 [INFO] [narusejun.com] acme: Trying to solve DNS-01\n2018/12/21 02:45:00 [INFO] [narusejun.com] Checking DNS record propagation using [1.0.0.1:53]\n2018/12/21 02:45:00 [INFO] Wait [timeout: 1m0s, interval: 2s]\n2018/12/21 02:45:37 [INFO] [narusejun.com] The server validated our request\n2018/12/21 02:45:38 [INFO] [narusejun.com, *.narusejun.com] acme: Validations succeeded; requesting certificates\n2018/12/21 02:45:39 [INFO] [narusejun.com] Server responded with a certificate.\n\n$ openssl x509 -in ~/.lego/certificates/narusejun.com.crt -text\nCertificate:\n    Data:\n        Version: 3 (0x2)\n        Serial Number:\n            fa:78:5b:6e:73:74:37:e6:c4:36:54:82:02:04:d2:7e:bd:0b\n        Signature Algorithm: sha256WithRSAEncryption\n        Issuer: CN = Fake LE Intermediate X1\n        Validity\n            Not Before: Dec 20 16:45:40 2018 GMT\n            Not After : Mar 20 16:45:40 2019 GMT\n        Subject: CN = narusejun.com\n        X509v3 extensions:\n            X509v3 Subject Alternative Name:\n                DNS:*.narusejun.com, DNS:narusejun.com\n```\n\n……と、サクッとワイルドカード証明書が取れてしまいました。すごい！便利！\n\n上の例はstaging環境から証明書を取得しているので、マネする際はご注意ください！\n詳しくは、例によって[公式ドキュメント](https://github.com/xenolf/lego)をごらんください。\n\n### traefikを使う\n\n[traefik](https://docs.traefik.io/)は強いL7ロードバランサみたいなものです（ざっくりとした説明）。\nLet's Encryptから自動で証明書を取る機能がついてるんですが、この機能は内部で先述したlegoを利用しています。\n\n[traefik](https://docs.traefik.io/)\n\n……ということは、**ConoHa DNSに対応**しています！\n詳しい説明は省きますが、[公式ドキュメント](https://docs.traefik.io/configuration/acme/)を参考に設定してみてください。\nちゃんとConoHa DNSと連携して動作することを確認済みです。\n\n## おわりに\n\n紹介したソフトウェア以外にも、LexiconやLegoを内部で使ってる系ソフトが実はConoHaに対応してるパターンがいっぱいあるかもしれません。このソフトでもConoHa DNS使えたよ！とかあったら教えてください。\nちなみに、[Caddy](https://caddyserver.com/)というHTTPサーバが[Legoの全DNSプロバイダに対応しそう](https://caddy.community/t/poll-we-can-end-dns-provider-plugins-should-we/4887)だったりするので、そしたらConoHaも使えるようになりますね！\n\n----\n\nConoHaのDNS、めっちゃ便利なので使いましょう。\nAPIでレコードいじれるし、ゾーン数がいくつあっても無料ってマジ！？神じゃん。\n\nあっ、ボクのパソコン見てください。\n\nhttps://twitter.com/sekai67/status/1053444090757435392\n\nhttps://twitter.com/sekai67/status/1053598421414596608\n\nhttps://twitter.com/sekai67/status/1053441437126127616\n","title":"ConoHaのDNSをAPIから操作する話","image":null,"tags":["API","ConoHa","DNS","Let's Encrypt","アドベントカレンダー"],"date":"2018-12-21T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"external","url":"https://trap.jp/post/334/","publisher":"東京工業大学デジタル創作同好会traP","title":"PrometheusでConoHa APIからメトリクスを取得してみる","tags":["traP","アドベントカレンダー","インフラ","ConoHa","監視","Prometheus"],"date":"2017-12-24T00:00:00.000Z"},{"type":"external","url":"https://trap.jp/post/158/","publisher":"東京工業大学デジタル創作同好会traP","title":"署名付きクッキー / Omniauth Strategyを書く / GitLabで独自認証","tags":["traP","アドベントカレンダー","認証","セキュリティ"],"date":"2016-12-25T00:00:00.000Z"},{"type":"article","slug":"14","body":"作りました\n\n[ConoHa Advent Calendar 2016](http://qiita.com/advent-calendar/2016/conoha) 24日目の記事です。\n\n[ConoHa Advent Calendar 2016](http://qiita.com/advent-calendar/2016/conoha)\n\n# ConoHaのDNS\n\n[ConoHa](https://www.conoha.jp/referral/?token=sp928CCbwhPZeu0SLEbeVyIhGOsIchLSzaun2yUbKWaR.q89860-OPA)には無料で使えるDNS機能が用意されています。\nなぜか[機能一覧](https://www.conoha.jp/function/)には乗ってません。見落としてるだけだろうか。GeoDNSは書いてある。\n[料金](https://www.conoha.jp/pricing/)ページには**「ドメインのレコードを登録して使うことができるDNS機能を無料提供。」**って書いてありますね。\n\n# 使ってみる\n\n登録がまだの人は急いで登録しましょう。\n[ココ](https://www.conoha.jp/referral/?token=sp928CCbwhPZeu0SLEbeVyIhGOsIchLSzaun2yUbKWaR.q89860-OPA)から登録するとクーポンもらえますよ。\n**電話認証**を選択するのを忘れずに。\n\nとりあえず、ConoHaにログインしたらまず右上のメールアドレスをクリックしてメニューを開き、「アカウント設定 > 表示設定 > モード設定」で**”このはモード”**を選択します。\n\n![](1.png)\nあぁ＾〜\n\n左のメニューから「DNS」を開けば、こんなカンジでDNSが使えます。\n\n![](2.png)\n\nもちろん、ドメインのレジストラの方でネームサーバをConoHaの`ns-a*.conoha.io`にしないとダメですよ。\n\nそれだけ。\n\n# DNS API\n\nコレだけだとまぁわざわざConoHaのDNSを使わなくてもレジストラ標準のDNSでいいじゃん！ってなるんですが、\nConoHaのDNSの強みは**APIから設定を操作できる**点にあります。\n\nCLIクライアントの[python-designateclient](http://docs.openstack.org/developer/python-designateclient/)があるのでそれを使いましょう。\n\n……だと終わってしまうので、自分が使いやすいように作った[conoha-dns](https://github.com/kaz/conoha-dns)を紹介します。\n\n# conoha-dns\n\nnodejsからDNS APIを叩くために書いたコードの副産物的に作りました。\n\nObjectStorageのCLIクライアント[conoha-ojs](https://github.com/hironobu-s/conoha-ojs)をリスペクトして\n- 認証情報をファイルに保存\n- シングルバイナリで動作\nするようになってます。\n\nAdC用に急ぎで作ったのでだいぶ作りが荒いです。\n問題が起きても責任は取れませんが、よかったら使ってください。\n\n[conoha-dns](https://github.com/kaz/conoha-dns)\n\n## 動作風景\n\nこういうかんじです。\n詳しい説明は[conoha-dns](https://github.com/kaz/conoha-dns)を見てね。\n\n```\n$ conoha-dns auth\nTenant ID: mytenantid\nAPI User: myusername\nPassword:\nOK\n\n$ conoha-dns add wataraijun.com\nid                                    name             ttl\n------------------------------------  ---------------  ----\nc8f8677e-742c-4ed6-9a53-de80d76571aa  wataraijun.com.  3600\n\n$ conoha-dns add www.wataraijun.com -t CNAME -d www.narusejun.com\nid                                    name                 type   ttl   data                priority\n------------------------------------  -------------------  -----  ----  ------------------  --------\nbb02410c-2761-4080-9b70-da7445fc714c  www.wataraijun.com.  CNAME  3600  www.narusejun.com.  null\n```\n\n## 感想\n\n- 見通しを立ててコード書くの難しい\n   - あとからいろいろ変えたらわけわからん設計になった\n- 同じコマンドで別のAPIを叩いてるのが気持ち悪いかもしれない\n   - python-swiftclientやconoha-ojsみたいに、`list`単体だとコンテナを一覧表示、`list hoge`だとコンテナの中身を一覧表示……みたいなイメージだったんだけど\n- Goはシングルバイナリで配布できる！とか持て囃されてるけどnodejsでもできるから！\n   - [nexe](https://github.com/nexe/nexe)というものを使います\n   - 一部動かないコードがあったり、nodeをまるごとコンパイルするのでクソ時間かかったりしますが……\n   - nodejs最高\n- ConoHaちゃんかわいい\n\n# 以上\n\nこのはちゃんが可愛すぎることを差し置いてもConoHaはめっちゃ良いサービスです。\nConoHa最高。\n\nサークルのブログにもConoHa関係の記事があります。\n[ConoHaでArchLinuxを動かすまで](https://trap.jp/post/39/)\n\n# 宣伝\n\n今年の冬コミ(C91)に技術系の合同誌を出します。\n\nトピックは\n- SQLインジェクション ([@N4RU5E](https://twitter.com/N4RU5E))\n- シェーダー(GLSL) ([@sobaya007](https://twitter.com/sobaya007))\n- 巡回セールスマン問題 ([@_n_ari](https://twitter.com/_n_ari))\n- LLVM ([@long_long_float](https://twitter.com/long_long_float))\n- ディープラーニング ([@to_huothu](https://twitter.com/to_huothu))\n\nの5つで200ページとなっております。\n角で殴られたら致命傷なカンジな厚さになってます。\n1000円です。\n\n**木曜日(1日目) 西地区“み”ブロック－18b**\n**「揚羽高校情報処理部」**\n\nでお待ちしています。よろしくお願いします！\n\n## 目次\n\n![](book1.png)\n![](book2.png)\n![](book3.png)\n","title":"ConoHaのDNS APIをCLIから叩くやつを作った","image":null,"tags":["アドベントカレンダー","ConoHa","DNS"],"date":"2016-12-24T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},{"type":"external","url":"https://trap.jp/post/30/","publisher":"東京工業大学デジタル創作同好会traP","title":"ボクは女の子になった (Live2D / clmtrackr)","tags":["traP","アドベントカレンダー","Live2D","clmtracker"],"date":"2015-12-22T00:00:00.000Z"}]},"__N_SSG":true}