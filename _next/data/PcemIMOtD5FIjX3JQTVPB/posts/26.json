{"pageProps":{"article":{"type":"article","slug":"26","body":"この記事は[CTF Advent Calendar 2018](https://adventar.org/calendars/3210)の23日目の記事です！\n\n[CTF Advent Calendar 2018](https://adventar.org/calendars/3210)\n\n本稿では、Ethereumスマートコントラクトを用いて、CTF（に限らず、様々なイベント）の賞金支払いをどう行うか？を検討してみます。\n\n## はじめに\n\n[**Capture The Flag**](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%97%E3%83%81%E3%83%A3%E3%83%BC%E3%83%BB%E3%82%B6%E3%83%BB%E3%83%95%E3%83%A9%E3%83%83%E3%82%B0#%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3)においては、その上位者に賞金が支払われる大会がしばしば開催されている。\n\nこうしたCTFをはじめとする各種賞金付き大会において、その賞金の支払いを**DApps**を用いて行う事を考える。\n\n## DAppsを用いる意義\n\n- 確かに賞金が用意されていることを証明できる\n- 主催者が賞金を支払う意志があることをアピールできる\n- 入賞者自身が引き出しを行うので、支払いの手間がかからない\n\n# DAppsを用いた賞金付きCTF\n\n今回は簡単化のため、**優勝者のみに賞金が支払われ**、**問題数は1つ**（正解のFLAGが1つ）の単純な大会を想定とする。\nまた、優勝者は「FLAGを入手し、賞金支払い手続きを最も早く行った参加者」と定義する。\n\nDAppsやブロックチェーンなど、分散基盤上で「賞金支払い」を行う場合に、大きく問題となるのが**未受理トランザクション**の存在である。\n要は、未受理のままネットワーク（mempool）を漂っているトランザクションをコピーしてより高い手数料を付与すれば、最初にトランザクションを投入した参加者の賞金受け取り権利を横取りできてしまう、という話である。\n\n優勝者が**必ず、もしくは極めて高い確率で賞金を手にする**ことができるDAppsを考えてみよう。\n\n## 従来手法\n\n### [1]: [Bitcoinによる新しいCapture The Flag（CTF）](https://qiita.com/yyu/items/b6f367eb876dd28e759a)\n\n[Bitcoinによる新しいCapture The Flag（CTF）](https://qiita.com/yyu/items/b6f367eb876dd28e759a)\n\nこの手法では、FLAG検証に参加者固有の値を用いることで先述の問題を解決している。\nブロックチェーン上に**各参加者ごとに固有のFLAGハッシュ**を予め記憶しておくことで、検証を行う。\n\nチーム$T_i$はFLAG文字列$F$を入手すると、$h_i=H(F||i)$を含むトランザクションを提出する。$H$は適当なハッシュ関数である。\nこのトランザクションに対し、予め記録されている$ans_i=H(h_i)$と比較することで正しいFLAGを持っているか検証できる。\n仮にチーム$T_j$がこのトランザクションをコピーしても、チーム$T_j$に対する正解$ans_j$は$ans_i$と異なるため、正解とみなされない。\nまた、$h_i$を入手してもハッシュの原像計算困難性により、$F$は入手できない。\n\nEthereumを用いて実装した例もある。\n\n[Solidityで作るCapture The Flag](http://lotz84.hatenablog.com/entry/2018/01/02/134056)\n\nしかし、[1]では**予めCTFイベントへの参加者が確定している**必要があり、開始時刻以降は参加者を追加できない。\n開催中にイベントの存在を知ったユーザが新たに参加できず、ユーザビリティを欠いている。\n\n### [2]: [ERC20トークンを用いた宝探しゲーム(真)の提案](https://trap.jp/post/561/)\n\n[ERC20トークンを用いた宝探しゲーム(真)の提案](https://trap.jp/post/561/)\n\nこの手法では、テーマとして「宝探し」を取り扱っているが、秘密の文字列を何らかの手段によって入手した参加者に報奨を与えるという点で、\n**お宝**を**FLAG**に、**ERC20トークン**を**賞金**と読み替えれば、CTFにおける賞金支払いに応用可能である。\n\n基本的なアイデアは[1]とほぼ同等で、**各参加者ごとに固有のFLAGハッシュ**がスマートコントラクト上に記録されている。\n\n[1]と異なるの　は、後から参加者の追加を可能としている点である。\n[1]がBitcoinの`scriptPubKey`で記述されているのに対して、[2]ではEthereumスマートコントラクト上で実装しているため、より柔軟なDAppsが記述できている。\n\nしかしながら、[2]では参加者の追加をするために**主催者が手数料を支払う必要がある**。\n一度デプロイが完了した後にも、コントラクトの面倒を見続ける必要があるのは欠点であると言えよう。\n\n加えて、DoS攻撃の余地がある。\nEthereumのEOAアドレスは無コストで生成可能であるので、何度も参加要求を送り続けければ、主催者のEthereumが枯渇してしまう。\nこれを防ぐには、何らかのオフチェーン要素とアドレスを紐付けて個人を特定する、CTFへの参加に手数料を徴収する、などが考えられる。\nしかし、これらは主催者側の負担が大きい。到底De-centralized Appsとは呼べるものではない！\n\nさらに、[2]では**主催者がこっそり賞金を自分の懐に収める**可能性を排除できない。\n[1]では、予め参加者を確定させておくことでこの問題をうまく回避している。\n\n## 提案手法\n\n提案手法では、**後から参加者が追加可能であり、その際に手数料を必要としない**ことを目標とする。\nまた、DAppsプラットフォームとしては、Ethereumスマートコントラクトを想定している。\n\n## [N案]: コミットメントによる引き出し\n\n本手法では、予めFLAGハッシュをコントラクト上に乗せることなく、検証時には参加者ごとに異なるFLAGハッシュを用いて検証することを目指す。\nこれを可能とするのが**コミットメント方式**である。コミットメントについては、[Wikipediaの解説](https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%83%A1%E3%83%B3%E3%83%88)や[ブロックチェーンを利用した公平なガチャの提案](https://qiita.com/yyu/items/4eaa43693e39c60a8661)が詳しい。\n\nコントラクト上には、FLAG文字列$F$のハッシュ$F'=H(F)$を予め記録されている。$H$は適当なハッシュ関数である。\nまず、**commit**と**reveal**の2つの操作を定義する。\n\n**commit**は、言わば**賞金を引き出す権利の予約**である。\n参加者$T_i$は、FLAG文字列$F$を入手すると、自身のアドレス$A_i$を用いてコミット$C_i=H(F||A_i)$を送信する。\nコミット$C_i$は、コントラクト上に格納される。また、$C_i$は従来手法で予めコントラクト上に格納しておくものと等しい。\nこの時点では、トランザクションを観察しても$F$は復元困難である。これがコミットメント方式の**秘匿性**である。\n\n**reveal**は、**予約した権利が正当であることを証明**し、それを行使して**賞金を引き出す**操作である。\n参加者$T_i$は、FLAG文字列$F$を単に公開する。コントラクトは、$H(F)$を計算し、予め記録されている$F'$と比較して、FLAG文字列が正しいかを確認した後、\n$H(F||A_i)$を計算し、commit時に記録された$C_i$と比較を行うことで、**参加者はcommitの時点でこのFLAGを本当に所有していたのかを確認する**。\n以上で、commit時点で正しいことFLAGを所有していたことが確認されれば、直ちに賞金を支払う。\ncommit時に提出したFLAGは、reveal時に変更できない。これがコミットメント方式の**拘束性**である。\n\nコミットメント方式による賞金支払いでは、**revealした瞬間にFLAG文字列が全員に対して明らかになる**点に注意が必要である。\nそのため、検証を2段階に分けたとしても、誰かがrevealした瞬間に高手数料でcommitし、すぐにrevealすれば逆転可能性がある。\n\nこの手法のキモは、**commitから一定時間（ブロック高）が経過しないとrevealできない**ような制約を設けることにある。\nこれによって、revealトランザクションを投入した瞬間から一定時間内は、**攻撃者は絶対に引き出しができない**。\nしたがって、この一定時間内にrevealトランザクションが承認されれば良いため、極めて高い確率で**最も先にcommitした参加者に**賞金が支払われる。\n一定時間の遅延は、言わば攻撃者の賞金引き出し操作を遅延させるために存在するものと言える。\n\nSolidityによる実装例は以下。\n\n```js\npragma solidity ^0.5.0;\n\ncontract Prize {\n\tevent Commit(address sender, uint revealable);\n\n\tbytes32 private flagHash;\n\n\tmapping(address => bytes32) private commits;\n\tmapping(address => uint) private revealable;\n\n\tconstructor(bytes32 _flagHash) public payable {\n\t\tflagHash = _flagHash;\n\t}\n\n\tfunction commit(bytes32 commitment) external {\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, revealable[msg.sender] = block.number + 128);\n\t}\n\tfunction reveal(bytes32 flag) external {\n\t\trequire(calcFlagHash(flag) == flagHash);\n\t\trequire(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\trequire(block.number >= revealable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction calcFlagHash(bytes32 flag) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag));\n\t}\n\tfunction calcCommitment(bytes32 flag, address sender) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n```\n\n## [A案]: コミットメントによる権利移転\n\n[N案]では、要件を満たす賞金支払いDAppsを定義したが、この方式には1点課題が残る。\nそれは、**一定時間が経過しなくてもrevealできてしまう**点である。\n\nこの場合、正しく実装されたコントラクトでは、支払いは行われず、**FLAGが想定より早く公開されてしまう**。\n一定時間が経過する前にrevealした参加者は、我々が苦心して用意した権利保護期間を自ら捨て去ってしまったことになるのだ！\n\n[N案]を拡張し、こうした誤操作が起こりえない、言わばフールプルーフ的な構造を取り入れたのが[A案]である。\n\n**commit**と**reveal**の2つに加えて、新たに**withdraw**操作を定義する。\n\n**commit**では、[N案]の$C_i$に加えて、commitした時刻（ブロック高）を記録しておく。\n\n**reveal**では、[N案]と同様の検証を行った後に、**権利の移転**を行う。\n[A案]では、コントラクト上で「現在の引き出し権利者」（優勝者）を記憶している。\n権利の移転とは、現在の権利者がcommitした時刻よりも、早い時刻にcommitした参加者がrevealした際に、権利を移動する操作である。\n\nそして**withdraw**は、引き出し権利を行使して賞金を引き出すものである。\nこの権利行使を遅延させるのが[A案]である。遅延は、「commit時から一定時間後」でもいいし「権利取得時から一定時間後」でも良い。\ncommit時から一定時間後としたほうが、参加者の待ち時間は短くなり、ユーザビリティが向上するだろう。\n\nこれによって、commit後に即時revealしても損をすることがない。\nrevealトランザクションを見てすぐさま権利を横取りしたとしても、withdrawの遅延によってすぐに引き出せないし、その間に正当権利者がrevealすれば良い。（commitが最も早いものが最終的な権利を得る。）\n\nSolidityによる実装例は以下。\n\n```js\npragma solidity ^0.5.0;\n\ncontract Prize {\n\tevent Commit(address sender, uint withdrawable);\n\tevent Reveal(address sender, uint withdrawable);\n\n\tbytes32 private flagHash;\n\taddress payable private winner;\n\n\tmapping(address => bytes32) private commits;\n\tmapping(address => uint) private withdrawable;\n\n\tconstructor(bytes32 _flagHash) public payable {\n\t\tflagHash = _flagHash;\n\t}\n\n\tfunction commit(bytes32 commitment) external {\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, withdrawable[msg.sender] = block.number + 128);\n\t}\n\tfunction reveal(bytes32 flag) external {\n\t\trequire(calcFlagHash(flag) == flagHash);\n\t\trequire(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\trequire(winner == 0 || withdrawable[msg.sender] < withdrawable[winner]);\n\t\temit Reveal(winner = msg.sender, withdrawable[msg.sender]);\n\t}\n\tfunction withdraw() external {\n\t\trequire(msg.sender == winner);\n\t\trequire(block.number >= withdrawable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\tfunction calcFlagHash(bytes32 flag) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag));\n\t}\n\tfunction calcCommitment(bytes32 flag, address sender) public pure returns(bytes32) {\n\t\treturn keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n```\n\n## 提案手法の課題\n\n### 主催者による賞金回収\n\n[2]の問題として上げた以下の点は、解決できていない。\n\n> **主催者がこっそり賞金を自分の懐に収める**可能性を排除できない。\n\nしかし、後から参加者の追加を許す場合では、この可能性を排除することは極めて難しい。\nこの問題についてはとりあえずは目をつむって、主催者は信頼に足る人間である、ということにしておこう……！\n\n### 暗号通貨に価値があることを前提としている\n\nまぁいいじゃん。\nアゼルバイジャン。\n\n## おわりに\n\nコミットメントの持つ秘匿性・束縛性を活用し、後から参加者が追加可能であり、その際に手数料を必要としない賞金支払いコントラクトを提案した。\n\n### 謝辞\n\n本稿は、[@42_0N](https://twitter.com/42_0N)氏との長時間に渡る議論を経て書き上げたものです。\nありがとナス！！！！！！！！\n\n----\n\nところで、最近公開したミニCTF:[NaruseJunCTF](https://we.are.participating.in.seccon.international/)はプレイして頂けましたか？\nなんと、全問正解者には賞金があります！（2018/12/23 現在 まだ賞金は残ってます）\n賞金支払いには[N案]コントラクトを用いていますヨ。DAppsによる賞金受け取りを是非体験してみてくださいネ。\n","title":"DAppsによる賞金付きCTF","image":null,"tags":["CTF","DApps","Ethereum","アドベントカレンダー","スマートコントラクト"],"date":"2018-12-23T00:00:00.000Z","updated":"2021-01-07T09:09:45.000Z"},"description":"この記事はCTF Advent Calendar 2018の23日目の記事です！ CTF Advent Calendar 2018 本稿では、Ethereumスマートコントラクトを用いて、CTF（に…","content":"<p>この記事は<a href=https://adventar.org/calendars/3210 rel=\"noopener noreferrer\"target=_blank>CTF Advent Calendar 2018</a>の23日目の記事です！<aside><a href=https://adventar.org/calendars/3210 rel=\"noopener noreferrer\"target=_blank style=background-image:url(https://adventar.org/og_image.png)><div><strong>CTF Advent Calendar 2018 - Adventar</strong><cite>adventar.org</cite><q cite=https://adventar.org/calendars/3210>CTFについて</q></div></a></aside><p>本稿では、Ethereumスマートコントラクトを用いて、CTF（に限らず、様々なイベント）の賞金支払いをどう行うか？を検討してみます。<h2>はじめに</h2><p><a href=https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%97%E3%83%81%E3%83%A3%E3%83%BC%E3%83%BB%E3%82%B6%E3%83%BB%E3%83%95%E3%83%A9%E3%83%83%E3%82%B0#%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3 rel=\"noopener noreferrer\"target=_blank><strong>Capture The Flag</strong></a>においては、その上位者に賞金が支払われる大会がしばしば開催されている。<p>こうしたCTFをはじめとする各種賞金付き大会において、その賞金の支払いを<strong>DApps</strong>を用いて行う事を考える。<h2>DAppsを用いる意義</h2><ul><li>確かに賞金が用意されていることを証明できる<li>主催者が賞金を支払う意志があることをアピールできる<li>入賞者自身が引き出しを行うので、支払いの手間がかからない</ul><h1>DAppsを用いた賞金付きCTF</h1><p>今回は簡単化のため、<strong>優勝者のみに賞金が支払われ</strong>、<strong>問題数は1つ</strong>（正解のFLAGが1つ）の単純な大会を想定とする。 また、優勝者は「FLAGを入手し、賞金支払い手続きを最も早く行った参加者」と定義する。<p>DAppsやブロックチェーンなど、分散基盤上で「賞金支払い」を行う場合に、大きく問題となるのが<strong>未受理トランザクション</strong>の存在である。 要は、未受理のままネットワーク（mempool）を漂っているトランザクションをコピーしてより高い手数料を付与すれば、最初にトランザクションを投入した参加者の賞金受け取り権利を横取りできてしまう、という話である。<p>優勝者が<strong>必ず、もしくは極めて高い確率で賞金を手にする</strong>ことができるDAppsを考えてみよう。<h2>従来手法</h2><h3>[1]: <a href=https://qiita.com/yyu/items/b6f367eb876dd28e759a rel=\"noopener noreferrer\"target=_blank>Bitcoinによる新しいCapture The Flag（CTF）</a></h3><aside><a href=https://qiita.com/yyu/items/b6f367eb876dd28e759a rel=\"noopener noreferrer\"target=_blank style=\"background-image:url(https://qiita-user-contents.imgix.net/https%3A%2F%2Fcdn.qiita.com%2Fassets%2Fpublic%2Farticle-ogp-background-1150d8b18a7c15795b701a55ae908f94.png?ixlib=rb-4.0.0&#38w=1200&#38mark64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTM4MCZ0eHQ2ND1RbWwwWTI5cGJ1T0JxLU9DaU9PQ2ktYVdzT09CbC1PQmhFTmhjSFIxY21VZ1ZHaGxJRVpzWVdmdnZJaERWRWJ2dklrJnR4dC1jb2xvcj0lMjMzMzMmdHh0LWZvbnQ9SGlyYWdpbm8lMjBTYW5zJTIwVzYmdHh0LXNpemU9NTQmdHh0LWNsaXA9ZWxsaXBzaXMmdHh0LWFsaWduPWNlbnRlciUyQ21pZGRsZSZzPTVhNDYyMjBhYzNjMGIzNGMxNjBjNzI4YjhlMGRhOGNm&#38mark-align=center%2Cmiddle&#38blend64=aHR0cHM6Ly9xaWl0YS11c2VyLWNvbnRlbnRzLmltZ2l4Lm5ldC9-dGV4dD9peGxpYj1yYi00LjAuMCZ3PTg0MCZoPTUwMCZ0eHQ2ND1RSGw1ZFEmdHh0LWNvbG9yPSUyMzMzMyZ0eHQtZm9udD1IaXJhZ2lubyUyMFNhbnMlMjBXNiZ0eHQtc2l6ZT00NSZ0eHQtYWxpZ249cmlnaHQlMkNib3R0b20mcz1jMWViYzM0Zjk1ZGY0NGI5YWRlZjJlNjA0MDExNzg4NA&#38blend-align=center%2Cmiddle&#38blend-mode=normal&#38s=aa868b4624307de550cb643cfaa9f627)\"><div><strong>Bitcoinによる新しいCapture The Flag（CTF） - Qiita</strong><cite>qiita.com</cite><q cite=https://qiita.com/yyu/items/b6f367eb876dd28e759a>はじめに Capture The Flag（CTF）とはセキュリティ系のコンテンストであり、いくつかの形式があるものの、ここではjeopardy形式と呼ばれるものについて説明する。jeopardy形式のCTFは暗号やバイナリ解析...</q></div></a></aside><p>この手法では、FLAG検証に参加者固有の値を用いることで先述の問題を解決している。 ブロックチェーン上に<strong>各参加者ごとに固有のFLAGハッシュ</strong>を予め記憶しておくことで、検証を行う。<p>チーム<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>T_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>T</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>はFLAG文字列<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>F</mi></mrow><annotation encoding=application/x-tex>F</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span></span></span></span></span>を入手すると、<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub><mo>=</mo><mi>H</mi><mo stretchy=false>(</mo><mi>F</mi><mi mathvariant=normal>∣</mi><mi mathvariant=normal>∣</mi><mi>i</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>h_i=H(F||i)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.84444em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\">h</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span><span class=mopen>(</span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=mord>∣</span><span class=mord>∣</span><span class=\"mord mathnormal\">i</span><span class=mclose>)</span></span></span></span></span>を含むトランザクションを提出する。<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>H</mi></mrow><annotation encoding=application/x-tex>H</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span></span></span></span></span>は適当なハッシュ関数である。 このトランザクションに対し、予め記録されている<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub><mo>=</mo><mi>H</mi><mo stretchy=false>(</mo><msub><mi>h</mi><mi>i</mi></msub><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>ans_i=H(h_i)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.58056em;vertical-align:-.15em></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">n</span><span class=mord><span class=\"mord mathnormal\">s</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span><span class=mopen>(</span><span class=mord><span class=\"mord mathnormal\">h</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span>と比較することで正しいFLAGを持っているか検証できる。 仮にチーム<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding=application/x-tex>T_j</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.969438em;vertical-align:-.286108em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>T</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.311664em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\"style=margin-right:.05724em>j</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.286108em><span></span></span></span></span></span></span></span></span></span></span>がこのトランザクションをコピーしても、チーム<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>T</mi><mi>j</mi></msub></mrow><annotation encoding=application/x-tex>T_j</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.969438em;vertical-align:-.286108em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>T</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.311664em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\"style=margin-right:.05724em>j</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.286108em><span></span></span></span></span></span></span></span></span></span></span>に対する正解<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>j</mi></msub></mrow><annotation encoding=application/x-tex>ans_j</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.716668em;vertical-align:-.286108em></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">n</span><span class=mord><span class=\"mord mathnormal\">s</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.311664em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\"style=margin-right:.05724em>j</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.286108em><span></span></span></span></span></span></span></span></span></span></span>は<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>a</mi><mi>n</mi><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>ans_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.58056em;vertical-align:-.15em></span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">n</span><span class=mord><span class=\"mord mathnormal\">s</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>と異なるため、正解とみなされない。 また、<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>h</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>h_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.84444em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\">h</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>を入手してもハッシュの原像計算困難性により、<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>F</mi></mrow><annotation encoding=application/x-tex>F</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span></span></span></span></span>は入手できない。<p>Ethereumを用いて実装した例もある。<aside><a href=https://lotz84.hatenablog.com/entry/2018/01/02/134056 rel=\"noopener noreferrer\"target=_blank style=background-image:url(https://ogimage.blog.st-hatena.com/8599973812324986035/8599973812332386652/1515923806)><div><strong>Solidityで作るCapture The Flag - lotzのブロチェ日記</strong><cite>lotz84.hatenablog.com</cite><q cite=https://lotz84.hatenablog.com/entry/2018/01/02/134056>qiita.com BitcoinでCapture The Flag(CTF)を作るという記事を読んでEthereumでの実現可能性に触れられていたので実際にSolidity + truffleを使って試してみました。Bitcoinでの実装については上記の記事をぜひ読んでみて下さい。</q></div></a></aside><p>しかし、[1]では<strong>予めCTFイベントへの参加者が確定している</strong>必要があり、開始時刻以降は参加者を追加できない。 開催中にイベントの存在を知ったユーザが新たに参加できず、ユーザビリティを欠いている。<h3>[2]: <a href=https://trap.jp/post/561/ rel=\"noopener noreferrer\"target=_blank>ERC20トークンを用いた宝探しゲーム(真)の提案</a></h3><aside><a href=https://trap.jp/post/561/ rel=\"noopener noreferrer\"target=_blank style=\"background-image:url(https://trap.jp/assets/logo/full_blue.svg?v=3b596d7c78)\"><div><strong>ERC20トークンを用いた宝探しゲーム(真)の提案【アドベントカレンダー2018 10日目】</strong><cite>trap.jp</cite><q cite=https://trap.jp/post/561/>ルール 参加者は、開催者が隠したお宝を見つけることで、保持しているERC20トークンを増やしていく。 参加者 開催前において、n人の参加者を予定しているとし、それぞれPi​と表す (i∈{1,…,n})。 開催中に参加者を増やすことができる。 お宝 開催前において、m個のお宝を予定しているとし、それぞれTj​と表す (j∈{1,…,m})。 お宝は、QRコードなどの、十分な長さのバイト列を表現できるものとする。 開催中にお宝を増やすことができる。 ゲームの流れ 開催前 各参加者Pi​は、ゲームで使用するアドレスai​を生成して公開する。 開催者は、各お宝Tj​に対応する十分な長さのバイト列b…</q></div></a></aside><p>この手法では、テーマとして「宝探し」を取り扱っているが、秘密の文字列を何らかの手段によって入手した参加者に報奨を与えるという点で、 <strong>お宝</strong>を<strong>FLAG</strong>に、<strong>ERC20トークン</strong>を<strong>賞金</strong>と読み替えれば、CTFにおける賞金支払いに応用可能である。<p>基本的なアイデアは[1]とほぼ同等で、<strong>各参加者ごとに固有のFLAGハッシュ</strong>がスマートコントラクト上に記録されている。<p>[1]と異なるの　は、後から参加者の追加を可能としている点である。 [1]がBitcoinの<code>scriptPubKey</code>で記述されているのに対して、[2]ではEthereumスマートコントラクト上で実装しているため、より柔軟なDAppsが記述できている。<p>しかしながら、[2]では参加者の追加をするために<strong>主催者が手数料を支払う必要がある</strong>。 一度デプロイが完了した後にも、コントラクトの面倒を見続ける必要があるのは欠点であると言えよう。<p>加えて、DoS攻撃の余地がある。 EthereumのEOAアドレスは無コストで生成可能であるので、何度も参加要求を送り続けければ、主催者のEthereumが枯渇してしまう。 これを防ぐには、何らかのオフチェーン要素とアドレスを紐付けて個人を特定する、CTFへの参加に手数料を徴収する、などが考えられる。 しかし、これらは主催者側の負担が大きい。到底De-centralized Appsとは呼べるものではない！<p>さらに、[2]では<strong>主催者がこっそり賞金を自分の懐に収める</strong>可能性を排除できない。 [1]では、予め参加者を確定させておくことでこの問題をうまく回避している。<h2>提案手法</h2><p>提案手法では、<strong>後から参加者が追加可能であり、その際に手数料を必要としない</strong>ことを目標とする。 また、DAppsプラットフォームとしては、Ethereumスマートコントラクトを想定している。<h2>[N案]: コミットメントによる引き出し</h2><p>本手法では、予めFLAGハッシュをコントラクト上に乗せることなく、検証時には参加者ごとに異なるFLAGハッシュを用いて検証することを目指す。 これを可能とするのが<strong>コミットメント方式</strong>である。コミットメントについては、<a href=https://ja.wikipedia.org/wiki/%E3%83%93%E3%83%83%E3%83%88%E3%82%B3%E3%83%9F%E3%83%83%E3%83%88%E3%83%A1%E3%83%B3%E3%83%88 rel=\"noopener noreferrer\"target=_blank>Wikipediaの解説</a>や<a href=https://qiita.com/yyu/items/4eaa43693e39c60a8661 rel=\"noopener noreferrer\"target=_blank>ブロックチェーンを利用した公平なガチャの提案</a>が詳しい。<p>コントラクト上には、FLAG文字列<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>F</mi></mrow><annotation encoding=application/x-tex>F</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span></span></span></span></span>のハッシュ<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msup><mi>F</mi><mo lspace=0em mathvariant=normal rspace=0em>′</mo></msup><mo>=</mo><mi>H</mi><mo stretchy=false>(</mo><mi>F</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>F'=H(F)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.751892em;vertical-align:0></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.751892em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span><span class=mopen>(</span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=mclose>)</span></span></span></span></span>を予め記録されている。<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>H</mi></mrow><annotation encoding=application/x-tex>H</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span></span></span></span></span>は適当なハッシュ関数である。 まず、<strong>commit</strong>と<strong>reveal</strong>の2つの操作を定義する。<p><strong>commit</strong>は、言わば<strong>賞金を引き出す権利の予約</strong>である。 参加者<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>T_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>T</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>は、FLAG文字列<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>F</mi></mrow><annotation encoding=application/x-tex>F</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span></span></span></span></span>を入手すると、自身のアドレス<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>A_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\">A</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>を用いてコミット<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub><mo>=</mo><mi>H</mi><mo stretchy=false>(</mo><mi>F</mi><mi mathvariant=normal>∣</mi><mi mathvariant=normal>∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>C_i=H(F||A_i)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.07153em>C</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span><span class=mopen>(</span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=mord>∣</span><span class=mord>∣</span><span class=mord><span class=\"mord mathnormal\">A</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span>を送信する。 コミット<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>C_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.07153em>C</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>は、コントラクト上に格納される。また、<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>C_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.07153em>C</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>は従来手法で予めコントラクト上に格納しておくものと等しい。 この時点では、トランザクションを観察しても<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>F</mi></mrow><annotation encoding=application/x-tex>F</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span></span></span></span></span>は復元困難である。これがコミットメント方式の<strong>秘匿性</strong>である。<p><strong>reveal</strong>は、<strong>予約した権利が正当であることを証明</strong>し、それを行使して<strong>賞金を引き出す</strong>操作である。 参加者<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>T_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>T</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>は、FLAG文字列<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>F</mi></mrow><annotation encoding=application/x-tex>F</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.68333em;vertical-align:0></span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span></span></span></span></span>を単に公開する。コントラクトは、<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>H</mi><mo stretchy=false>(</mo><mi>F</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>H(F)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span><span class=mopen>(</span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=mclose>)</span></span></span></span></span>を計算し、予め記録されている<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msup><mi>F</mi><mo lspace=0em mathvariant=normal rspace=0em>′</mo></msup></mrow><annotation encoding=application/x-tex>F'</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.751892em;vertical-align:0></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.751892em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mtight\"><span class=\"mord mtight\">′</span></span></span></span></span></span></span></span></span></span></span></span></span>と比較して、FLAG文字列が正しいかを確認した後、 <span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><mi>H</mi><mo stretchy=false>(</mo><mi>F</mi><mi mathvariant=normal>∣</mi><mi mathvariant=normal>∣</mi><msub><mi>A</mi><mi>i</mi></msub><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>H(F||A_i)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=\"mord mathnormal\"style=margin-right:.08125em>H</span><span class=mopen>(</span><span class=\"mord mathnormal\"style=margin-right:.13889em>F</span><span class=mord>∣</span><span class=mord>∣</span><span class=mord><span class=\"mord mathnormal\">A</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:0;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></span>を計算し、commit時に記録された<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>C_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.07153em>C</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>と比較を行うことで、<strong>参加者はcommitの時点でこのFLAGを本当に所有していたのかを確認する</strong>。 以上で、commit時点で正しいことFLAGを所有していたことが確認されれば、直ちに賞金を支払う。 commit時に提出したFLAGは、reveal時に変更できない。これがコミットメント方式の<strong>拘束性</strong>である。<p>コミットメント方式による賞金支払いでは、<strong>revealした瞬間にFLAG文字列が全員に対して明らかになる</strong>点に注意が必要である。 そのため、検証を2段階に分けたとしても、誰かがrevealした瞬間に高手数料でcommitし、すぐにrevealすれば逆転可能性がある。<p>この手法のキモは、<strong>commitから一定時間（ブロック高）が経過しないとrevealできない</strong>ような制約を設けることにある。 これによって、revealトランザクションを投入した瞬間から一定時間内は、<strong>攻撃者は絶対に引き出しができない</strong>。 したがって、この一定時間内にrevealトランザクションが承認されれば良いため、極めて高い確率で<strong>最も先にcommitした参加者に</strong>賞金が支払われる。 一定時間の遅延は、言わば攻撃者の賞金引き出し操作を遅延させるために存在するものと言える。<p>Solidityによる実装例は以下。<pre><code class=\"hljs language-js\">pragma solidity ^<span class=hljs-number>0.5</span><span class=hljs-number>.0</span>;\n\ncontract Prize {\n\tevent Commit(address sender, uint revealable);\n\n\tbytes32 private flagHash;\n\n\tmapping(<span class=hljs-function><span class=hljs-params>address</span> =></span> bytes32) private commits;\n\tmapping(<span class=hljs-function><span class=hljs-params>address</span> =></span> uint) private revealable;\n\n\t<span class=hljs-title>constructor</span>(<span class=hljs-params>bytes32 _flagHash</span>) <span class=hljs-title>public</span> <span class=hljs-title>payable</span> {\n\t\tflagHash = _flagHash;\n\t}\n\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>commit</span>(<span class=hljs-params>bytes32 commitment</span>) <span class=hljs-title>external</span> </span>{\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, revealable[msg.sender] = block.number + <span class=hljs-number>128</span>);\n\t}\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>reveal</span>(<span class=hljs-params>bytes32 flag</span>) <span class=hljs-title>external</span> </span>{\n\t\t<span class=hljs-built_in>require</span>(calcFlagHash(flag) == flagHash);\n\t\t<span class=hljs-built_in>require</span>(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\t<span class=hljs-built_in>require</span>(block.number >= revealable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>calcFlagHash</span>(<span class=hljs-params>bytes32 flag</span>) <span class=hljs-title>public</span> <span class=hljs-title>pure</span> <span class=hljs-title>returns</span>(<span class=hljs-params>bytes32</span>) </span>{\n\t\t<span class=hljs-keyword>return</span> keccak256(abi.encodePacked(flag));\n\t}\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>calcCommitment</span>(<span class=hljs-params>bytes32 flag, address sender</span>) <span class=hljs-title>public</span> <span class=hljs-title>pure</span> <span class=hljs-title>returns</span>(<span class=hljs-params>bytes32</span>) </span>{\n\t\t<span class=hljs-keyword>return</span> keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n</code></pre><h2>[A案]: コミットメントによる権利移転</h2><p>[N案]では、要件を満たす賞金支払いDAppsを定義したが、この方式には1点課題が残る。 それは、<strong>一定時間が経過しなくてもrevealできてしまう</strong>点である。<p>この場合、正しく実装されたコントラクトでは、支払いは行われず、<strong>FLAGが想定より早く公開されてしまう</strong>。 一定時間が経過する前にrevealした参加者は、我々が苦心して用意した権利保護期間を自ら捨て去ってしまったことになるのだ！<p>[N案]を拡張し、こうした誤操作が起こりえない、言わばフールプルーフ的な構造を取り入れたのが[A案]である。<p><strong>commit</strong>と<strong>reveal</strong>の2つに加えて、新たに<strong>withdraw</strong>操作を定義する。<p><strong>commit</strong>では、[N案]の<span class=\"math math-inline\"><span class=katex><span class=katex-mathml><math xmlns=http://www.w3.org/1998/Math/MathML><semantics><mrow><msub><mi>C</mi><mi>i</mi></msub></mrow><annotation encoding=application/x-tex>C_i</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.83333em;vertical-align:-.15em></span><span class=mord><span class=\"mord mathnormal\"style=margin-right:.07153em>C</span><span class=msupsub><span class=\"vlist-t vlist-t2\"><span class=vlist-r><span class=vlist style=height:.31166399999999994em><span style=top:-2.5500000000000003em;margin-left:-.07153em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class=\"mtight reset-size6 size3 sizing\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=vlist-s>​</span></span><span class=vlist-r><span class=vlist style=height:.15em><span></span></span></span></span></span></span></span></span></span></span>に加えて、commitした時刻（ブロック高）を記録しておく。<p><strong>reveal</strong>では、[N案]と同様の検証を行った後に、<strong>権利の移転</strong>を行う。 [A案]では、コントラクト上で「現在の引き出し権利者」（優勝者）を記憶している。 権利の移転とは、現在の権利者がcommitした時刻よりも、早い時刻にcommitした参加者がrevealした際に、権利を移動する操作である。<p>そして<strong>withdraw</strong>は、引き出し権利を行使して賞金を引き出すものである。 この権利行使を遅延させるのが[A案]である。遅延は、「commit時から一定時間後」でもいいし「権利取得時から一定時間後」でも良い。 commit時から一定時間後としたほうが、参加者の待ち時間は短くなり、ユーザビリティが向上するだろう。<p>これによって、commit後に即時revealしても損をすることがない。 revealトランザクションを見てすぐさま権利を横取りしたとしても、withdrawの遅延によってすぐに引き出せないし、その間に正当権利者がrevealすれば良い。（commitが最も早いものが最終的な権利を得る。）<p>Solidityによる実装例は以下。<pre><code class=\"hljs language-js\">pragma solidity ^<span class=hljs-number>0.5</span><span class=hljs-number>.0</span>;\n\ncontract Prize {\n\tevent Commit(address sender, uint withdrawable);\n\tevent Reveal(address sender, uint withdrawable);\n\n\tbytes32 private flagHash;\n\taddress payable private winner;\n\n\tmapping(<span class=hljs-function><span class=hljs-params>address</span> =></span> bytes32) private commits;\n\tmapping(<span class=hljs-function><span class=hljs-params>address</span> =></span> uint) private withdrawable;\n\n\t<span class=hljs-title>constructor</span>(<span class=hljs-params>bytes32 _flagHash</span>) <span class=hljs-title>public</span> <span class=hljs-title>payable</span> {\n\t\tflagHash = _flagHash;\n\t}\n\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>commit</span>(<span class=hljs-params>bytes32 commitment</span>) <span class=hljs-title>external</span> </span>{\n\t\tcommits[msg.sender] = commitment;\n\t\temit Commit(msg.sender, withdrawable[msg.sender] = block.number + <span class=hljs-number>128</span>);\n\t}\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>reveal</span>(<span class=hljs-params>bytes32 flag</span>) <span class=hljs-title>external</span> </span>{\n\t\t<span class=hljs-built_in>require</span>(calcFlagHash(flag) == flagHash);\n\t\t<span class=hljs-built_in>require</span>(calcCommitment(flag, msg.sender) == commits[msg.sender]);\n\t\t<span class=hljs-built_in>require</span>(winner == <span class=hljs-number>0</span> || withdrawable[msg.sender] &#60 withdrawable[winner]);\n\t\temit Reveal(winner = msg.sender, withdrawable[msg.sender]);\n\t}\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>withdraw</span>(<span class=hljs-params></span>) <span class=hljs-title>external</span> </span>{\n\t\t<span class=hljs-built_in>require</span>(msg.sender == winner);\n\t\t<span class=hljs-built_in>require</span>(block.number >= withdrawable[msg.sender]);\n\t\tselfdestruct(msg.sender);\n\t}\n\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>calcFlagHash</span>(<span class=hljs-params>bytes32 flag</span>) <span class=hljs-title>public</span> <span class=hljs-title>pure</span> <span class=hljs-title>returns</span>(<span class=hljs-params>bytes32</span>) </span>{\n\t\t<span class=hljs-keyword>return</span> keccak256(abi.encodePacked(flag));\n\t}\n\t<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>calcCommitment</span>(<span class=hljs-params>bytes32 flag, address sender</span>) <span class=hljs-title>public</span> <span class=hljs-title>pure</span> <span class=hljs-title>returns</span>(<span class=hljs-params>bytes32</span>) </span>{\n\t\t<span class=hljs-keyword>return</span> keccak256(abi.encodePacked(flag, sender));\n\t}\n}\n</code></pre><h2>提案手法の課題</h2><h3>主催者による賞金回収</h3><p>[2]の問題として上げた以下の点は、解決できていない。<blockquote><p><strong>主催者がこっそり賞金を自分の懐に収める</strong>可能性を排除できない。</blockquote><p>しかし、後から参加者の追加を許す場合では、この可能性を排除することは極めて難しい。 この問題についてはとりあえずは目をつむって、主催者は信頼に足る人間である、ということにしておこう……！<h3>暗号通貨に価値があることを前提としている</h3><p>まぁいいじゃん。 アゼルバイジャン。<h2>おわりに</h2><p>コミットメントの持つ秘匿性・束縛性を活用し、後から参加者が追加可能であり、その際に手数料を必要としない賞金支払いコントラクトを提案した。<h3>謝辞</h3><p>本稿は、<a href=https://twitter.com/42_0N rel=\"noopener noreferrer\"target=_blank>@42_0N</a>氏との長時間に渡る議論を経て書き上げたものです。 ありがとナス！！！！！！！！<hr><p>ところで、最近公開したミニCTF:<a href=https://we.are.participating.in.seccon.international/ rel=\"noopener noreferrer\"target=_blank>NaruseJunCTF</a>はプレイして頂けましたか？ なんと、全問正解者には賞金があります！（2018/12/23 現在 まだ賞金は残ってます） 賞金支払いには[N案]コントラクトを用いていますヨ。DAppsによる賞金受け取りを是非体験してみてくださいネ。"},"__N_SSG":true}